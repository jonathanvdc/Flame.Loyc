<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Syntax</name>
    </assembly>
    <members>
        <member name="T:Loyc.Syntax.BaseParser`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator). Note: this is the old (harder to use) base class design. You 
            should use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> instead.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.EofInt">
            <summary>Returns the value used for EOF (normally 0)</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LT(System.Int32)">
            <summary>Returns the token at lookahead i (e.g. <c>Source[InputPosition + i]</c>
            if the tokens come from a list called Source) </summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.ToString(`1)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LaIndexToSourcePos(System.Int32)">
            <summary>Converts a lookahead token index to a character index (used 
            for error reporting). Returns -1 if unsuccessful.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String)">
            <summary>Records an error or throws an exception.</summary>
            <param name="lookaheadIndex">Location of the error relative to the
            current <c>InputPosition</c>. When called by BaseParser, lookaheadIndex 
            is always equal to 0.</param>
            <remarks>
            The default implementation throws a <see cref="T:System.FormatException"/>.
            When overriding this method, you can convert the lookaheadIndex
            to a <see cref="T:Loyc.Syntax.SourcePos"/> using the expression
            <c>SourceFile.IndexToLine(LT(lookaheadIndex).StartIndex)</c>. This only
            works if an <c>ISourceFile</c> object was provided to the constructor of 
            this class, and <c>Token</c> implements <see cref="T:Loyc.Syntax.Lexing.ISimpleToken"/>.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.SourceFile">
            <summary>The <see cref="T:Loyc.Syntax.ISourceFile"/> object that was provided to the constructor, if any.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.LT0">
            <summary>Next token to parse (cached; is set to LT(0) whenever InputPosition is changed).</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.InputPosition">
            <summary>Current position of the next token to be parsed.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.LA0Int">
            <summary>Returns the token type of _lt0 (normally _lt0.TypeInt)</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`2.SavePosition">
            <summary>A helper class used by LLLPG for backtracking.</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`1">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator). Note: this is the old (harder to use) base class. You should 
            use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> instead. This class is
            now an alias for BaseParser{Token,int}.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParserForList`3">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This version of BaseParserForList has TokenList as a generic parameter. 
            Compared to using IList{Token} directly, this can increase performance in 
            case the list is a value type (e.g. <c>InternalList&lt;Token&gt;</c>).
            </remarks>
            <typeparam name="Token">Data type of complete tokens in the token list. A 
            token contains the type of a "word" in the program (string, identifier, plus 
            sign, etc.), a value (e.g. the name of an identifier), and a range of 
            characters in the source file. See <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/>.
            Note: Token is usually a small struct; this class does not expect that it
            will ever be null.</typeparam>
            <typeparam name="MatchType">A data type, usually int, that represents a 
            token type (identifier, operator, etc.) and implements <see cref="T:System.IEquatable`1"/>
            so it can be compared for equality with other token types; this is also the 
            type of the <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/> property.</typeparam>
            <typeparam name="List">Data type of the list that contains the tokens (one 
            often uses IList{Token}, but one could use <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            for potentially higher performance.)</typeparam>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.#ctor(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes this object to begin parsing the specified tokens.</summary>
            <param name="list">A list of tokens that the derived class will parse.</param>
            <param name="eofToken">A token value to return when the input position 
            reaches the end of the token list. If possible this EOF token should 
            contain the position of EOF, but if you have arranged to use zero as 
            your EOF token type, default</param>
            <param name="file">A source file object that will be returned by the 
            <see cref="T:Loyc.Syntax.SourceFile"/> property. By default, this object is used to 
            get the file name, line number and column number shown in parser errors. 
            If you are using <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/> or <see cref="T:Loyc.Syntax.Lexing.LexerSource"/>, 
            you can get this object from the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> 
            property. The <see cref="T:Loyc.Syntax.SourceFile"/> property (in this class) will 
            return this value. It can be null, which will cause default error 
            messages to show the character index instead of the file, line number 
            and column number.</param>
            <param name="startIndex">The initial index from which to start reading
            tokens from the list (normally 0).</param>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.ToString(`1)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParserForList`3.TokenList">
            <summary>The IList{Token} that was provided to the constructor, if any.</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParserForList`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This base class for LLLPG parsers reads tokens from <see cref="T:System.Collections.Generic.IList`1"/>,
            but you can also pass an <see cref="T:System.Collections.Generic.IEnumerable`1"/> or 
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> to the constructor and it will use
            <see cref="T:Loyc.Collections.BufferedSequence`1"/> to convert the sequence to a list.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.BaseParserNoBacktracking`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This base class for LLLPG parsers simply requires an enumerator to work,
            and it has a small buffer to hold lookahead tokens. Old tokens are 
            forgotten, so this base class does not support backtracking (i.e. syntactic 
            predicates), but it can save memory. Please use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> 
            if your input sequence comes in the form of a list.
            <para/>
            This version of BaseParser has Enumerator as a generic parameter. Compared 
            to using IEnumerator{Token} directly, this can increase performance in case 
            Enumerator is a value type (e.g. <c>List&lt;Token&gt;.Enumerator</c>).
            <para/>
            (I wrote this class by mistake... I actually forgot about backtracking!)
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.#ctor(`1,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes this object to begin parsing the specified tokens.</summary>
            <param name="sequence">A list of tokens to be parsed.</param>
            <param name="eofToken">A token value to return when the input position 
            reaches the end of the token list.</param>
            <param name="file">A source file object that will be returned by the <see cref="T:Loyc.Syntax.SourceFile"/>
            property. By default, this object is used to get the file name, line 
            number and column number shown in parser errors. If you are using 
            <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/>, you can get this object from the
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> property. The <see cref="T:Loyc.Syntax.SourceFile"/>.
            property (in this class) will return this value. It can be null, which
            means that default error messages will show the character index instead
            of the file, line number and column number.</param>
            <param name="startIndex">The initial value of the InputPosition property.
            This is informational only, and has no effect on the behavior of this 
            class.</param>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.LT(System.Int32)">
            <summary>Returns the Token at lookahead i, where 0 is the next token.
            This class does not support negative lookahead because old tokens from 
            the IEnumerator are discarded.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.ToString(System.Int32)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParserNoBacktracking`2.InputPosition">
            <summary>Cumulative index of the next token to be parsed.</summary>
            <remarks>This class doesn't care what the absolute InputPosition is, 
            since it reads from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>. This property
            is constrained to always increase, since old tokens are forgotten.</remarks>
        </member>
        <member name="T:Loyc.Syntax.BaseParserNoBacktracking`1">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <seealso cref="T:Loyc.Syntax.BaseParserNoBacktracking`2"/>
        </member>
        <member name="T:Loyc.Syntax.CodeSymbols">
            <summary>
            A list of common symbols that have special meaning somewhere in Loyc or EC#:
            operators, built-in data types, keywords, trivia, etc.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.List">
            <summary># is used for lists of things in definition constructs, e.g. 
                <c>#class(Derived, #(Base, IEnumerable), {...})</c>.
            For a time, #tuple was used for this purpose; the problem is that a
            find-and-replace operation intended to find run-time tuples could 
            accidentally match one of these lists. So I decided to dedicate # 
            for use inside special constructs; its meaning depends on context.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.BadCode">
            <summary>An identifier or call with this Name indicates that parsing or 
            analysis failed earlier and that an error message has already been 
            printed.</summary>
            <remarks>When code in a compiler sees this symbol it should be seen as
            a signal to avoid printing further error messages that involve the same
            node. Typically, a node named #badCode should replace the bad code, and 
            it may have an argument that describes the error, which could be printed 
            at runtime if compilation continues to completion.</remarks>
            <example>#badCode("Argument 2: Cannot convert 'string' to 'int'.")</example>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Internal">
            <summary>Provides general access within a library or program (implies
            #protected_in).</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Public">
            <summary>Provides general access, even outside the assembly (i.e. 
            dynamic-link library). Implies #internal, #protectedIn and #protected.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.ProtectedIn">
            <summary>Provides access to derived classes only within the same library
            or program (i.e. assembly). There is no C# equivalent to this keyword,
            which does not provide access outside the assembly.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Protected">
            <summary>Provides access to all derived classes. Implies #protected_in.
            #protected #internal corresponds to C# "protected internal"</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Private">
            <summary>Revokes access outside the same space and nested spaces. This 
            can be used in spaces in which the default is not private to request
            private as a starting point. Therefore, other flags (e.g. #protected_ex)
            can be added to this flag to indicate what access the user wants to
            provide instead.
            </summary><remarks>
            The name #private may be slightly confusing, since a symbol marked 
            #private is not actually private when there are other access markers
            included at the same time. I considered calling it #revoke instead,
            since its purpose is to revoke the default access modifiers of the
            space, but I was concerned that someone might want to reserve #revoke 
            for some other purpose.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.FilePrivate">
            <summary>Used with #alias to indicate that an alias is local to the
            current source file. <c>[#filePrivate] #alias(X = Y, #())</c> is the long
            form of <c>using X = Y</c> in EC#.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.TriviaRawTextBefore">
            if `#trivia_rawText` has the string "eat my shorts!" attached as its Value,
            then `[#trivia_rawText] x;` is printed "eat my shorts!x;". It can also be
            structured as a call: `[#trivia_rawText("eat my shorts!")] x;`
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.TriviaWordAttribute">
            "#trivia_wordAttribute": in EC#, this trivia is placed on an identifier treated as an attribute (e.g. partial, async).
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.RawText">
            #rawText must have a Value, or be a call with a single literal argument.
            The Value is converted to a string and printed out by EcsNodePrinter 
            without any filtering, e.g. `#rawText("Hello")` is printed `Hello`.
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.IsArrayKeyword(Loyc.Symbol)">
            <summary>Returns true if the symbol is a pair of square brackets with 
            zero or more commas inside, e.g. "[,]", which in EC# represents an array 
            type of a specific number of dimensions.</summary>
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.CountArrayDimensions(Loyc.Symbol)">
            <summary>Returns the rank of an array symbol when <see cref="M:Loyc.Syntax.CodeSymbols.IsArrayKeyword(Loyc.Symbol)"/> 
            is true, or 0 if the symbol does not represent an array type.</summary>
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.GetArrayKeyword(System.Int32)">
            <summary>Gets the Symbol for an array with the specified number of 
            dimensions, e.g. <c>GetArrayKeyword(3)</c> returns <c>[,,]</c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.IParsingService">
            <summary>An interface that encapsulates the lexer, parser, and printer
            of a programming language, or a non-programming language that can be 
            represented by Loyc trees.</summary>
            <remarks>
            The simplest way to parse code is with the extension method 
            <c>Parse(string, IMessageSink msgs = null, Symbol inputType = null)</c>.
            The simplest way to print is with <c>Print(LNode, IMessageSink)</c>
            <para/>
            The ToString() method should return a string that indicates the 
            programming language represented by this object, e.g. "LES 1.0 parser".
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink)">
            <summary>Returns a lexer that is configured to begin reading the specified file.</summary>
            <param name="file">Text to be tokenized (e.g. <see cref="T:Loyc.UString"/>)</param>
            <param name="fileName">File name to be associated with any errors that occur.</param>
            <param name="msgs">Error messages are sent to this object.</param>
            <remarks>
            The returned lexer should be a "simple" tokenizer. If the language uses 
            tree lexing (in which tokens are grouped by parentheses and braces),
            the returned lexer should NOT include the grouping process, and it 
            should not remove comments, although it may skip spaces and perhaps
            newlines. If there is a preprocessor, it should not run.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Symbol)">
            <summary>Parses a source file into one or more Loyc trees.</summary>
            <param name="file">input file or string.</param>
            <param name="msgs">output sink for error and warning messages.</param>
            <param name="inputType">Indicates the kind of input: <c>Exprs</c> (one 
            or more expressions, typically seprated by commas but this is language-
            defined), <c>Stmts</c> (a series of statements), or <c>File</c> (an 
            entire source file). <c>null</c> is a synonym for <c>File</c>.</param>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Syntax.Lexing.ILexer,Loyc.IMessageSink,Loyc.Symbol)">
            <summary>If <see cref="P:Loyc.Syntax.IParsingService.HasTokenizer"/> is true, this method accepts a 
            lexer returned by Tokenize() and begins parsing.</summary>
            <param name="msgs">output sink for error and warning messages.</param>
            <param name="inputType">Indicates how the input should be interpreted:
            <see cref="F:Loyc.Syntax.ParsingService.File"/>, <see cref="F:Loyc.Syntax.ParsingService.Exprs"/> or
            <see cref="F:Loyc.Syntax.ParsingService.Stmts"/>. The default input type should be
            File.</param>
            <exception cref="T:System.NotSupportedException">HasTokenizer is false.</exception>
            <remarks>
            This method adds any preprocessing steps to the lexer (tree-ification 
            or token preprocessing) that are required by this language before it 
            sends the results to the parser. If possible, the output is computed 
            lazily.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.IListSource{Loyc.Syntax.Lexing.Token},Loyc.Syntax.ISourceFile,Loyc.IMessageSink,Loyc.Symbol)">
            <summary>Parses a token tree, such as one that came from a token literal.</summary>
            <remarks>
            Some languages may offer token literals, which are stored as token trees
            that can be processed by "macros" or compiler plugins. A macro may wish 
            to parse some of the token literal using the host language's parser 
            (e.g. LLLPG needs to do this), so this method is provided for that 
            purpose.
            </remarks>
            <exception cref="T:System.NotSupportedException">This feature is not supported 
            by this parsing service.</exception>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Print(Loyc.Syntax.LNode,Loyc.IMessageSink,System.Object,System.String,System.String)">
            <summary>Converts the specified syntax tree to a string.</summary>
            <param name="node">A syntax tree to print.</param>
            <param name="msgs">If errors or warnings occur during printing, they are sent here.</param>
            <param name="mode">Language-defined configuration. It is suggested 
            that the printing service should accept ParsingService.Exprs, 
            ParsingService.Stmts and ParsingService.File as possible printing 
            modes.</param>
            <param name="indentString">Indent character for multi-line nodes</param>
            <param name="lineSeparator">Newline string for multi-line nodes</param>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.FileExtensions">
            <summary>Standard file extensions for this language, without leading 
            dots, with the first one being the most common.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.HasTokenizer">
            <summary>Returns true if the Tokenize() method is available.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.Printer">
            <summary>Gets a printer delegate that you can use with 
            <see cref="P:Loyc.Syntax.LNode.Printer"/> and <see cref="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.LNodePrinter)"/>,
            or null if there is no corresponding printer available for the parser
            reresented by this object.</summary>
        </member>
        <member name="T:Loyc.Syntax.ParsingService">
            <summary>Extension methods for <see cref="T:Loyc.Syntax.IParsingService"/>.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingService.Exprs">
            <summary>Tells <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Symbol)"/> to treat the input 
            as a single expression or expression list (which, in most languages, 
            is comma-separated).</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingService.Stmts">
            <summary>Tells <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Symbol)"/> to treat the input
            as a list of statements. If the language makes a distinction between 
            executable and declaration contexts, this refers to the executable 
            context.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingService.File">
            <summary>Tells <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Symbol)"/> to treat the input
            as a complete source file (this should be the default, i.e. null will
            do the same thing).</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.PushCurrent(Loyc.Syntax.IParsingService)">
            <summary>Sets the current language service, returning a value suitable 
            for use in a C# using statement, which will restore the old service.</summary>
            <param name="newValue">new value of Current</param>
            <example><code>
            LNode code;
            using (var old = ParsingService.PushCurrent(LesLanguageService.Value))
                code = ParsingService.Current.ParseSingle("This is les code;");
            </code></example>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.PrintMultiple(Loyc.Syntax.LNodePrinter,System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},Loyc.IMessageSink,System.Object,System.String,System.String)">
            <summary>Converts a sequences of LNodes to strings, adding a newline after each.</summary>
            <param name="printer">Printer for a single LNode.</param>
            <param name="mode">A language-specific way of modifying printer behavior.
            The printer ignores the mode object if it does not not understand it.</param>
            <param name="indentString">A string to print for each level of indentation, such as a tab or four spaces.</param>
            <param name="lineSeparator">Line separator, typically "\n" or "\r\n".</param>
            <returns>A string form of the nodes.</returns>
        </member>
        <member name="P:Loyc.Syntax.ParsingService.Current">
            <summary>Gets or sets the active language service on this thread. If 
            no service has been assigned on this thread, returns <see cref="F:Loyc.Syntax.Les.LesLanguageService.Value"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.ParsingService.PushedCurrent">
            <summary>Returned by <see cref="M:Loyc.Syntax.ParsingService.PushCurrent(Loyc.Syntax.IParsingService)"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesLanguageService">
            <summary>The <see cref="F:Loyc.Syntax.Les.LesLanguageService.Value"/> property provides easy access to the lexer, 
            parser and printer for Loyc Expression Syntax (LES).</summary>
            <remarks>
            LES overview: http://sourceforge.net/apps/mediawiki/loyc/index.php?title=LES
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.LesLexer">
            <summary>Lexer for EC# source code (see <see cref="T:Loyc.Syntax.Lexing.ILexer"/>).</summary>
            <seealso cref="T:Loyc.Syntax.Lexing.TokensToTree"/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer">
            <summary>Alias for <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/> where C is <see cref="T:Loyc.Collections.ICharSource"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer`1">
            <summary>The recommended base class for lexers generated by LLLPG,
            when not using the <c>inputSource</c> option.</summary>
            <remarks>
            If you are using the <c>inputSource</c> and <c>inputClass</c> options,
            use <see cref="T:Loyc.Syntax.Lexing.LexerSource`1"/> instead.
            <para/>
            This class contains many methods required by LLLPG, such as 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.NewSet(System.Int32[])"/>, <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.LA(System.Int32)"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LA0"/>, 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Skip"/>, <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Match(System.Collections.Generic.HashSet{System.Int32})"/>(...), and <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.TryMatch(System.Collections.Generic.HashSet{System.Int32})"/>(...), along with a few properties that are not 
            used by LLLPG that you still might want to have around, such as 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.FileName"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.CharSource"/> and 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/>.
            <para/>
            It also implements the caching behavior for which <see cref="T:Loyc.Collections.ICharSource"/>
            was created. See the documentation of <see cref="T:Loyc.Collections.ICharSource"/> for more
            information.
            <para/>
            All lexers derived from BaseLexer should call <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/>
            at the end of their newline rule, or they can borrow the newline 
            parser built into BaseLexer, which is called <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/>.
            It is possible to tell LLLPG about the base class implementation
            of Newline() like this:
            <code>
              extern token Newline @[ '\r' '\n'? | '\n' ];
            </code>
            The <c>extern</c> modifier tells LLLPG not to generate code for the
            rule, but the rule must still have a body so that LLLPG can perform 
            prediction.
            <para/>
            The recommended way to report error messages is to use <see cref="T:Loyc.IMessageSink"/>,
            e.g.
            <code>
              IMessageSink _sink = MessageSink.Current; // constructor injection would be better
              
              protected override void Error(int lookaheadIndex, string message)
              {
                  int index = InputPosition + lookaheadIndex;
                  _sink.Write(MessageSink.Error, SourceFile.IndexToLine(index), message);
              }
            </code>
            </remarks>
            <typeparam name="CharSrc">A class that implements ICharSource. In order
            to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>Initializes BaseLexer.</summary>
            <param name="source">A source of characters, e.g. <see cref="T:Loyc.UString"/>.</param>
            <param name="fileName">A file name associated with the characters, 
            which will be used for error reporting.</param>
            <param name="inputPosition">A location to start lexing (normally 0).
            Careful: If you're starting to lex in the middle of the file, the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> still starts at 1, and (if <c>newSourceFile</c>
            is true) the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> object may or may not discover 
            line breaks prior to the starting point, depending on how it is used.</param>
            <param name="newSourceFile">Whether to create a <see cref="T:Loyc.Syntax.Lexing.LexerSourceFile`1"/>
            object (an implementation of <see cref="T:Loyc.Syntax.ISourceFile"/>) to keep track 
            of line boundaries. The <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> property will point
            to this object, and it will be null if this parameter is false. Using 
            'false' will avoid memory allocation, but prevent you from mapping 
            character positions to line numbers and vice versa. However, this
            object will still keep track of the current <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> 
            and <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/> (the index where the current line started) 
            when this parameter is false.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Reset(`0,System.String,System.Int32,System.Boolean)">
            <summary>Reinitializes the object, as if you called the constructor again.</summary>
            <remarks>
            See the constructor for documentation of the parameters.
            <para/>
            This method can be used to avoid memory allocations when you
            need to parse many small strings in a row. If that's your goal, you 
            should set the <c>newSourceFile</c> parameter to false if possible.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Skip">
            <summary>Increments InputPosition. Called by LLLPG when prediction 
            already verified the input (and caller doesn't save LA(0))</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline">
            <summary>The lexer should call this method, which updates 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> and <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>, each time it 
            encounters a newline, even inside comments and strings.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline">
            <summary>Default newline parser that matches '\n' or '\r' unconditionally.</summary>
            <remarks>
            You can use this implementation in an LLLPG lexer with "extern", like so:
            <c>extern rule Newline @[ '\r' + '\n'? | '\n' ];</c>
            By using this implementation everywhere in the grammar in which a 
            newline is allowed (even inside comments and strings), you can ensure
            that <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/> is called, so that the line number
            is updated properly.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Error(System.Int32,System.String)">
            <summary>This method is called to handle errors that occur during lexing.
            Its default behavior is to throw a FormatException.</summary>
            <param name="lookaheadIndex">Index where the error occurred, relative to
            the current InputPosition (i.e. InputPosition + lookaheadIndex is the
            position of the error).</param>
            <param name="message">An error message, not including the error location.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Error(System.Int32,System.String,System.Object[])">
            <summary>This method is called to format and handle errors that occur 
            during lexing.</summary>
            <param name="lookaheadIndex">Index where the error occurred, relative to
            the current InputPosition (i.e. InputPosition + lookaheadIndex is the
            position of the error).</param>
            <param name="format">An error description with argument placeholders.</param>
            <param name="args">Arguments to insert into the error message.</param>
            <remarks>By default, this method calls <c>Error(lookaheadIndex, msg)</c> where
            msg is the result of formatting the message with <see cref="M:Loyc.Localize.From(Loyc.Symbol,System.String,System.Object[])"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.RangesToString(System.Collections.Generic.IList{System.Int32})">
            <summary>Converts a list of character ranges to a string, e.g. for input
            list {'*','*','a','z'}, the output is "'*' 'a'..'z'".</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.PrintChar(System.Int32,System.Text.StringBuilder)">
            <summary>Prints a character as a string, e.g. <c>'a' -> "'a'"</c>, with 
            the special value -1 representing EOF, so PrintChar(-1, ...) == "EOF".</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber">
            <summary>Current line number. Starts at 1 for the first line, unless derived class changes it.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt">
            <summary>Index at which the current line started.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer`1.SavePosition">
            <summary>A helper class used by LLLPG for backtracking.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILexer">
            <summary>
            A standard interface for lexers.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.ILexer.NextToken">
            <summary>Scans the next token and returns information about it.</summary>
            <returns>The next token, or null at the end of the source file.</returns>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer.SourceFile">
            <summary>The file being lexed.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer.ErrorSink">
            <summary>Event handler for errors.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer.IndentLevel">
            <summary>Indentation level of the current line. This is updated after 
            scanning the first whitespaces on a new line, and may be reset to zero 
            when <see cref="M:Loyc.Syntax.Lexing.ILexer.NextToken"/> returns a newline.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer.LineNumber">
            <summary>Current line number (1 for the first line).</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer.InputPosition">
            <summary>Current input position (an index into SourceFile.Text).</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.LesLexer.SkipValueParsing">
            <summary>Used for syntax highlighting, which doesn't care about token values.
            This option causes the Token.Value to be set to a default, like '\0' for 
            single-quoted strings and 0 for numbers. Operator names are still parsed.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},Loyc.UString)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes. Supports quote types '\'', '"' and '`'.</summary>
            <param name="sourceText">input text</param>
            <param name="onError">Called in case of parsing error (unknown escape sequence or missing end quotes)</param>
            <param name="indentation">Inside a triple-quoted string, any text
            following a newline is ignored as long as it matches this string. 
            For example, if the text following a newline is "\t\t Foo" and this
            string is "\t\t\t", the tabs are ignored and " Foo" is kept.</param>
            <returns>The decoded string</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.
            Firstly, it recognizes triple-quoted strings (''' """ ```). These 
            strings enjoy special newline handling: the newline is always 
            interpreted as \n regardless of the actual kind of newline (\r and 
            \r\n newlines come out as \n), and indentation following the newline
            can be stripped out. Triple-quoted strings can have escape sequences
            that use both kinds of slash, like so: <c>\n/ \r/ \'/ \"/ \0/</c>.
            However, there are no unicode escapes (\u1234/ is NOT supported).
            <para/>
            Secondly, it recognizes normal strings (' " `). These strings stop 
            parsing (with an error) at a newline, and can contain C-style escape 
            sequences: <c>\n \r \' \" \0</c> etc. C#-style verbatim strings are 
            NOT supported.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes (see documentation of the first overload) into a 
            StringBuilder.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.UnescapeString(Loyc.UString@,System.Char,System.Boolean,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString)">
            <summary>Parses a normal or triple-quoted string whose starting quotes 
            have been stripped out. If triple-quote parsing was requested, stops 
            parsing at three quote marks; otherwise, stops parsing at a single 
            end-quote or newline.</summary>
            <returns>true if parsing stopped at one or three quote marks, or false
            if parsing stopped at the end of the input string or at a newline (in
            a string that is not triple-quoted).</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.ParseIdentifier(Loyc.UString@,System.Action{System.Int32,System.String},System.Boolean@)">
            <summary>Parses an LES-style identifier such as <c>foo</c>, <c>@foo</c>, 
            <c>@`foo`</c> or <c>@--punctuation--</c>. Also recognizes <c>#`foo`</c>.
            </summary>
            <param name="source">Text to parse. On return, the range has been 
            decreased by the length of the token; this method also stops if this
            range becomes empty.</param>
            <param name="onError">A method to call on error</param>
            <param name="checkForNamedLiteral">This is set to true when the input 
            starts with @ but is a normal identifier, which could indicate that 
            it is an LES named literal such as @false or @null.</param>
            <returns>The parsed version of the identifier.</returns>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.ParseNumberCore(Loyc.UString,System.Boolean,System.Int32,System.Boolean,Loyc.Symbol,System.String@)">
            <summary>Parses the digits of a literal (integer or floating-point),
            not including the radix prefix (0x, 0b) or type suffix (F, D, L, etc.)</summary>
            <param name="source">Digits of the number (not including radix prefix or type suffix)</param>
            <param name="isFloat">Whether the number is floating-point</param>
            <param name="numberBase">Radix. Must be 2 (binary), 10 (decimal) or 16 (hexadecimal).</param>
            <param name="typeSuffix">Type suffix: F, D, M, U, L, UL, or null.</param>
            <param name="error">Set to an error message in case of error.</param>
            <returns>Boxed value of the literal, null if total failure (result 
            is not null in case of overflow), or <see cref="F:Loyc.Syntax.CodeSymbols.Sub"/> (-)
            if isNegative is true but the type suffix is unsigned or the number 
            is larger than long.MaxValue.</returns>
        </member>
        <member name="P:Loyc.Syntax.Les.LesLexer.ErrorSink">
            <summary>Error messages are given to the message sink.</summary>
            <remarks>The context argument will have type SourcePos.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.LesNodePrinter">
            <summary>Prints a Loyc tree in LES (Loyc Expression Syntax) format.</summary>
            <remarks>Unless otherwise noted, the default value of all options is false.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Les.LesNodePrinter.StartStmt">
            <summary>Context: beginning of statement (';' printed at the end)</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.LesNodePrinter.StartExpr">
            <summary>Context: beginning of main expression (potential superexpression)</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.LesNodePrinter.ContinueExpr">
            <summary>Context: second, third, etc. expression in a superexpression.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.AllowExtraParenthesis">
            <summary>Introduces extra parenthesis to express precedence, without
            using an empty attribute list @() to allow perfect round-tripping.</summary>
            <remarks>For example, the Loyc tree <c>x * #+(a, b)</c> will be printed 
            <c>x * (a + b)</c>, which is a different tree (due to the parenthesis, 
            <c>a + b</c> is nested in a call to the empty identifier \\``, which
            represents parenthesis.)</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.OmitMissingArguments">
            <summary>When an argument to a method or macro has the value #missing,
            it will be omitted completely if this flag is set.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.OmitSpaceTrivia">
            <summary>When this flag is set, space trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaSpaceAfter"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.OmitComments">
            <summary>When this flag is set, comment trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaSLCommentAfter"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.QuoteUnprintableLiterals">
            <summary>When the printer encounters an unprintable literal, it calls
            Value.ToString(). When this flag is set, the string is placed in double
            quotes; when this flag is clear, it is printed as raw text.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.OmitUnknownTrivia">
            <summary>Causes unknown trivia (other than comments, spaces and raw 
            text) to be dropped from the output.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.PrintExplicitTrivia">
            <summary>Causes comments and spaces to be printed as attributes in order 
            to ensure faithful round-trip parsing. By default, only "raw text" and
            unrecognized trivia is printed this way. Note: #trivia_inParens is 
            always printed as parentheses.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.ObeyRawText">
            <summary>Causes raw text to be printed verbatim, as the EC# printer does.
            When this option is false, raw text trivia is printed as a normal 
            attribute.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.LesNodePrinter.Mode.Wsa">
            <summary>Whitespace agnostic mode. ':' cannot be used to begin a 
            python-style code block.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.LesNodePrinter.Mode.InParens">
            <summary>Inside parenthesis (implies Wsa, and additionally allows 
            ':' as an operator).</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.INodePrinterWriter">
            <summary>This interface is implemented by helper objects that handle the 
            low-level details of node printing. It is used by <see cref="T:Loyc.Syntax.Les.LesNodePrinter"/>.</summary>
            <remarks>Specifically, INodePrinterWriter objects are in charge of how much
            to indent lines of code, and ensuring that there are spaces between tokens
            whenever omitting a space would screw up parsing.
            <para/>
            Although this interface is also used by EC#, I've kept it in the 
            Les namespace because I'm not yet confident that it's a <i>good</i> design 
            for arbitrary languages.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.INodePrinterWriter.Target">
            <summary>Gets the object being written to (TextWriter or StringBuilder)</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.NodePrinterWriterBase">
            <summary>Abstract base class for <see cref="T:Loyc.Syntax.Les.INodePrinterWriter"/>. Has an
            protected <c>_indentLevel</c> field that is increased by Indent() and 
            decreased by Dedent().</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.DefaultNodePrinterWriter">
            <summary>Base class for the helper classes of <see cref="T:Loyc.Syntax.Les.LesNodePrinter"/>
            and <see cref="!:Ecs.EcsNodePrinter"/>, called LesNodePrinterWriter and 
            EcsNodePrinterWriter. See <see cref="T:Loyc.Syntax.Les.INodePrinterWriter"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesNodePrinterWriter">
            <summary>Helper class of <see cref="T:Loyc.Syntax.Les.LesNodePrinter"/> that ensures there is 
            a tokens are spaced apart properly.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesParser">
            <summary>Parses LES (Loyc Expression Syntax) code into a sequence of Loyc 
            trees (<see cref="T:Loyc.Syntax.LNode"/>), one per top-level statement.</summary>
            <remarks>
            You can use <see cref="F:Loyc.Syntax.Les.LesLanguageService.Value"/> with <see cref="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,System.String,Loyc.IMessageSink,Loyc.Symbol)"/>
            to easily parse a text string (holding zero or more LES statements) into a Loyc tree.
            <para/>
            This class expects to receive tokens from <see cref="T:Loyc.Syntax.Les.LesLexer"/> that have been 
            preprocessed by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>, with whitespace tokens filtered out.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrinterAndParserTests.Test(System.Boolean,System.Int32,System.String,Loyc.Syntax.LNode[])">
            <summary>Runs a printer or parser test.</summary>
            <param name="parseErrors">-1 if the printer and parser should both 
            test this example. If above -1, only the parser will run this example,
            and this parameter specifies the number of parse errors to expect 
            (may be 0).</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Loyc.Syntax.Les.LesPrecedence" -->
        <member name="T:Loyc.Syntax.Les.LesPrecedenceMap">
            <summary>This class's main job is to maintains a table of 
            <see cref="T:Loyc.Syntax.Precedence"/> values for LES operators. When you ask about a
            new operator, its precedence is cached for future reference.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.Reset">
            <summary>Forgets previously encountered operators to save memory.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.Find(Loyc.Syntax.OperatorShape,System.Object,System.Boolean)">
            <summary>Gets the precedence of a prefix, suffix, or infix operator in 
            LES, under the assumption that the operator isn't surrounded in 
            backticks (in which case its precedence is always Backtick).</summary>
            <param name="op">Parsed form of the operator. op must be a Symbol, but 
            the parameter has type object to avoid casting Token.Value in the parser.</param>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.IsOpChar(System.Char)">
            <summary>Returns true if this character is one of those that operators are normally made out of in LES.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.IsNaturalOperator(Loyc.Symbol)">
            <summary>Returns true if the given Symbol can be printed as an operator 
            without escaping it.</summary>
            <remarks>The parser should read something like <c>+/*</c> as an operator
            with three characters, rather than "+" and a comment, but the printer 
            should be conservative, so this function returns false in such a case:
            "Be liberal in what you accept, and conservative in what you produce."</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.RequiresBackticks(Loyc.Symbol)">
            <summary>Returns true if a given Les operator can only be printed with 
            backticks, because a leading backslash is insufficient.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.ToSuffixOpName(System.Object)">
            <summary>Given a normal operator symbol like <c>(Symbol)"++"</c>, gets
            the suffix form of the name, such as <c>(Symbol)"suf++"</c>. In LES,
            operators that end with a backslash (\) are always suffix operators, so
            their names are left unchanged.</summary>
            <remarks>op must be a Symbol, but the parameter has type object to avoid casting Token.Value in the parser.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.IsSuffixOperatorName(Loyc.Symbol,Loyc.Symbol@,System.Boolean)">
            <summary>Decides whether the name appears to represent a suffix operator 
            of the form <c>sufOP</c> or <c>OP\</c>.</summary>
            <param name="name">Potential operator name to evaluate.</param>
            <param name="bareName">If the name starts with "suf", this is the same 
            name without "suf", otherwise it is set to <c>name</c> itself. This
            output is calculated even if the function returns false.</param>
            <param name="checkNatural">If true, part of the requirement for 
            returning true will be that IsNaturalOperator(bareName) == true.</param>
        </member>
        <member name="T:Loyc.Syntax.Les.LesPrinterTests">
            <summary>Uses the parser tests as the basis for printer tests. Since the
            printer isn't done yet, we simply make sure that after parsing something, 
            we can print it out and re-parse what was printed to get the same Loyc tree.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.TokenExt">
            <summary>Provides the <c>Type()</c> extension method required by 
            <see cref="T:Loyc.Syntax.Lexing.Token"/> and the ToString(Token) method to express an LES token
            as a string, for tokens that contain sufficient information to do so.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.TokenExt.Type(Loyc.Syntax.Lexing.Token)">
            <summary>Converts <c>t.TypeInt</c> to <see cref="T:Loyc.Syntax.Les.TokenType"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.TokenExt.ToString(Loyc.Syntax.Lexing.Token)">
            <summary>Expresses an LES token as a string.</summary>
            <remarks>Note that some Tokens do not contain enough information to
            reconstruct a useful token string, e.g. comment tokens do not store the 
            comment but merely contain the location of the comment in the source code.
            For performance reasons, a <see cref="T:Loyc.Syntax.Lexing.Token"/> does not have a reference 
            to its source file, so this method cannot return the original string.
            <para/>
            The results are undefined if the token was not produced by <see cref="T:Loyc.Syntax.Les.LesLexer"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerWrapper">
            <summary>A base class for wrappers that modify lexer behavior.
            Implements the ILexer interface, except for the NextToken() method.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILllpgApi`3">
            <summary>For reference purposes, this interface is a list of the non-static 
            methods that LLLPG expects to be able to call when it is generating code. 
            LLLPG does not actually need lexers and parsers to implement this interface;
            they simply need to implement the same set of methods as this interface 
            contains.</summary>
            <typeparam name="Token">The return value of the Match methods. LLLPG does 
            not care and does not need to know what this type is. In lexers, these 
            methods typically return the character that was matched (i.e. int, because
            EOF is -1), and in parsers they should return the token that was matched.</typeparam>
            <typeparam name="MatchType">The data type of arguments to Match, 
            MatchExcept, TryMatch and TryMatchExcept. In lexers, MatchType is always 
            int. In parsers, by default, LLLPG generates code as though MatchType is 
            same as LaType, but one often uses int instead, e.g. because enums do not
            implement <see cref="T:System.IEquatable`1"/> as required by 
            <see cref="T:Loyc.Syntax.BaseParser`2"/>. you're using
            <see cref="T:Loyc.Syntax.BaseParser`2"/> with LaType=int token 
            type is an enum, which for some reason does not implement 
            IEquatable{T}. So, often, when using BaseParser{Token you need to use the matchType(int) 
            option to change MatchType to int.</typeparam>
            <typeparam name="LaType">The data type of LA0 and LA(i). This is always int 
            in lexers, but in parsers you can use the laType(...) option to change this 
            type.</typeparam>
            <seealso cref="T:Loyc.Syntax.Lexing.ILllpgLexerApi`1"/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILllpgLexerApi`1">
            <summary>For reference purposes, this interface contains the non-static 
            methods that LLLPG expects lexers to implement. LLLPG does not actually 
            expect lexers to implement this interface; they simply need to implement 
            the same set of methods as this interface contains.</summary>
            <typeparam name="Token">The return value of the Match() methods, which is
            the input value (character) actually encountered in the stream. This type 
            is usually int.</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSource`1">
            <summary>An implementation of the LLLPG Lexer API, used with the LLLPG
            options <c>inputSource</c> and <c>inputClass</c>.</summary>
            <remarks>
            This derived class simply makes public all of the LLLPG APIs which are 
            marked protected in <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/>.
            </remarks>
            <example>
            LLLPG(lexer(inputSource(src), inputClass(LexerSource))) {
            	static rule int ParseInt(string input) {
            		var src = (LexerSource&lt;UString&gt;)input;
            		@[ (d:='0'..'9' {$result = $result * 10 + (d - '0');})+ ];
            	}
            }
            </example>
            <typeparam name="CharSrc">A class that implements ICharSource. In order
            to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSourceWorkaround`1">
            <summary>This class only exists to work around a limitation of the C# language:
            "cannot change access modifiers when overriding 'protected' inherited member Error(...)".</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>Initializes LexerSource.</summary>
            <param name="source">A source of characters, e.g. <see cref="T:Loyc.UString"/>.</param>
            <param name="fileName">A file name associated with the characters, 
            which will be used for error reporting.</param>
            <param name="inputPosition">A location to start lexing (normally 0).
            Careful: If you're starting to lex in the middle of the file, the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> still starts at 1, and (if <c>newSourceFile</c>
            is true) the <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.SourceFile"/> object may or may not discover 
            line breaks prior to the starting point, depending on how it is used.</param>
            <param name="newSourceFile">Whether to create a <see cref="T:Loyc.Syntax.Lexing.LexerSourceFile`1"/>
            object (an implementation of <see cref="T:Loyc.Syntax.ISourceFile"/>) to keep track 
            of line boundaries. The <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.SourceFile"/> property will point
            to this object, and it will be null if this parameter is false. Using 
            'false' will avoid memory allocation, but prevent you from mapping 
            character positions to line numbers and vice versa. However, this
            object will still keep track of the current <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> 
            and <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.LineStartAt"/> (the index where the current line started) 
            when this parameter is false.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Reset(`0,System.String,System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Skip">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.AfterNewline">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Newline">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.PrintChar(System.Int32,System.Text.StringBuilder)">
            <inheritdoc/>
        </member>
        <member name="P:Loyc.Syntax.Lexing.LexerSource`1.ErrorSink">
            <summary>Gets or sets an object that displays error messages. The 
            default value of this property is null, in which case any error that
            occurs will be thrown as a <c>FormatException</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.LexerSource`1.LineStartAt">
            <inheritdoc/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSource">
            <summary>A synonym for <see cref="T:Loyc.Syntax.Lexing.LexerSource`1"/> where C is <see cref="T:Loyc.Collections.ICharSource"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSourceFile`1">
            <summary>Adds the <see cref="M:Loyc.Syntax.Lexing.LexerSourceFile`1.AfterNewline(System.Int32)"/> method to <see cref="T:Loyc.Syntax.SourceFile"/>.</summary>
            <remarks>
            When implementing a lexer, the most efficient approach to building the list
            of line breaks is to save the location of each newline as it is encountered 
            while lexing, rather than doing a separate pass over the file just to find 
            line breaks. This class supports this optimization.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.SourceFile`1">
            <summary>A default implementation of ISourceFile based on <see cref="T:Loyc.Syntax.IndexPositionMapper"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.IndexPositionMapper`1">
            <summary>
            Helper class for mapping from indexes to SourcePos and back.
            </summary><remarks>
            This class's job is to keep track of the locations of line breaks in order
            to map from indices to SourcePos objects or vice versa. Converting indexes 
            to SourcePos is commonly needed for error reporting; lexers, parsers and 
            code analyzers typically use indexes (simple integers) internally, but must
            convert to SourcePos in order to communicate with the end user. Occasionally
            one may wish to convert in the reverse direction also (SourcePos to index).
            <para/>
            Line breaks themselves are classified as being at the end of each line.
            So if the file is "Bob\nJoe", <c>IndexToLine(3).Line == 1</c>, not 2.
            <para/>
            The outputs are immutable and this class assumes the input file never 
            changes. However, this class is not entirly multi-thread-safe until the 
            entire input file or string has been scanned, since the list of line breaks
            is built on-demand, without locking.
            </remarks>
            <typeparam name="CharSource">A type that implements <c>IListSource(Char)</c>.
            Originally this class did not have any type parameters and dealt with
            <c>IListSource(Char)</c>, but it was made generic so that one could wrap
            value types such as <c>UString</c> without boxing.
            </typeparam>
        </member>
        <member name="T:Loyc.Syntax.IIndexPositionMapper">
            <summary>
            This interface is for classes that can convert indexes to SourcePos
            structures and back.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.IIndexToLine">
            <summary>Contains <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> method.</summary>
            <seealso cref="T:Loyc.Syntax.IIndexPositionMapper"/>
        </member>
        <member name="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)">
            <summary>Returns the position in a source file of the specified index.</summary>
            <remarks>If index is negative, this should return a SourcePos where 
            Line and PosInLine are zero (signifying an unknown location). If index 
            is beyond the end of the file, this should retun the final position in 
            the file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.IIndexPositionMapper.LineToIndex(System.Int32)">
            <summary>Returns the index in a source file of the beginning of the 
            specified line, where the first line is number 1, not 0.</summary>
            <remarks>If lineNo is zero, this method should return -1 (signifying 
            an unknown location). If lineNo is larger than the largest line 
            number, this method should return the index of end-of-file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.IndexPositionMapper`1.#ctor(`0,Loyc.Syntax.SourcePos)">
            <summary>Initializes CharIndexPositionMapper.</summary>
            <param name="source">An immutable list of characters.</param>
            <param name="startingPos">Optional. The first character of <c>source</c> 
            will be considered to have the file name and line number specified by 
            this object. If this is null, IndexToLine() will return a blank file 
            name ("").</param>
        </member>
        <member name="M:Loyc.Syntax.IndexPositionMapper`1.Reset(`0,System.String)">
            <summary>Reinitializes the object (as though the constructor were called again).</summary>
        </member>
        <member name="T:Loyc.Syntax.ISourceFile">
            <summary>Represents a text file with a file name and its textual content,
            plus the data necessary to convert between line-column positions and 
            0-based integer indexes.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSourceFile`1.AfterNewline(System.Int32)">
            <summary>Allows a lexer to record the index of the character after 
            each line break, in the order they exist in the file or string.</summary>
            <param name="index">Index of the first character after the newline.</param>
            <remarks>
            A lexer is not required to call this method; if the lexer doesn't call 
            it, the list of line breaks (which is used to map indexes to line 
            numbers and vice versa) will be built on-demand when one calls methods
            such as <c>IndexToLine</c>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenListAsLexer">
            <summary>Adapter: converts <c>IEnumerable(Token)</c> to the <see cref="T:Loyc.Syntax.Lexing.ILexer"/> interface.</summary>
            <remarks>
            The LineNumber property is computed on-demand by the <see cref="T:Loyc.Syntax.ISourceFile"/> provided.
            <para/>
            TODO: IndentLevel does not work.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenTree">
            <summary>A list of Token structures along with the <see cref="T:Loyc.Syntax.ISourceFile"/> 
            object that represents the source file that the tokens came from.</summary>
            <remarks>This class is called <c>TokenTree</c> because certain kinds of 
            tokens used by some parsers are formed into trees by using <see cref="T:Loyc.Syntax.Lexing.TokenTree"/> 
            as the type of the <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> of certain tokens. Specifically,
            the LES and EC# parsers expect open-bracket and open-brace tokens ('(', 
            '[' and '{') to have a child <see cref="T:Loyc.Syntax.Lexing.TokenTree"/> that contains all the 
            tokens within a pair of brackets or braces. Typically this tree is not 
            created directly by the lexer, but by a helper class (<see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>).
            <para/>
            Caution: this class is mutable, even though TokenTrees are sometimes stored
            in <see cref="T:Loyc.Syntax.LNode"/>s which are supposed to be immutable. Please do not
            modify token trees that are stored inside LNodes.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Clone">
            <summary>Gets a deep (recursive) clone of the token tree.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Equals(Loyc.Syntax.Lexing.TokenTree)">
            <summary>Compares the elements of the token tree for equality.</summary>
            <remarks>Because <see cref="T:Loyc.Syntax.LNode"/>s are compared by value and not by 
            reference, and LNodes can contain TokenTrees, TokenTrees should also be
            compared by value.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.ToLNodes">
            <summary>Converts this list of <see cref="T:Loyc.Syntax.Lexing.Token"/> to a list of <see cref="T:Loyc.Syntax.LNode"/>.</summary>
            <remarks>See <see cref="M:Loyc.Syntax.Lexing.Token.ToLNode(Loyc.Syntax.ISourceFile)"/> for more information.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceTag">
            <summary><see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/> is used in <see cref="F:Loyc.Syntax.Lexing.Token.Value"/>
            to represent whitespace and comments, which allows them to be quickly 
            filtered out.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.Token">
            <summary>
            A common token type recommended for Loyc languages that want to use 
            features such as token literals or the <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/> class.
            </summary>
            <remarks>
            For performance reasons, a Token ought to be a structure rather than
            a class. But if Token is a struct, we have a conundrum: how do we support 
            tokens from different languages? We can't use inheritance since structs
            do not support it. When EC# is ready, we could use a single struct plus
            an alias for each language, but of course this structure predates the 
            implementation of EC#.
            <para/>
            Luckily, tokens in most languages are very similar. A four-word structure
            generally suffices:
            <ol>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.TypeInt"/>: each language can use a different set of token types 
            represented by a different <c>enum</c>. All enums can be converted to 
            an integer, so <see cref="T:Loyc.Syntax.Lexing.Token"/> uses Int32 as the token type. In order
            to support DSLs via token literals (e.g. LLLPG is a DSL inside EC#), the
            TypeInt should be based on <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>.</li>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.Value"/>: this can be any object. For literals, this should 
            be the actual value of the literal, for whitespace it should be 
            <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>, etc. See <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> for 
            the complete list.</li>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.StartIndex"/>: location in the original source file where 
            the token starts.</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Length"/>: length of the token in the source file (24 bits).</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Style"/>: 8 bits for other information.</li>
            </ol>
            Originally I planned to use <see cref="T:Loyc.Symbol"/> as the common token 
            type, because it is extensible and could nicely represent tokens in all
            languages; unfortunately, Symbol may reduce parsing performance because 
            it cannot be used with the switch opcode (i.e. the switch statement in 
            C#), so I decided to switch to integers instead and to introduce the 
            concept of <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>, which is derived from 
            <see cref="T:System.Type"/> using <see cref="F:Loyc.Syntax.Lexing.TokenKind.KindMask"/>.
            Each language should have, in the namespace of that language, an
            extension method <c>public static TokenType Type(this Token t)</c> that 
            converts the TypeInt to the enum type for that language.
            <para/>
            To save space (and because .NET doesn't handle large structures well),
            tokens do not know what source file they came from and cannot convert 
            their location to a line number. For this reason, one should keep a
            reference to the <see cref="T:Loyc.Syntax.ISourceFile"/> and call <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> 
            to get the source location.
            <para/>
            A generic token also cannot convert itself to a properly-formatted 
            string. The <see cref="M:Loyc.Syntax.Lexing.Token.ToString"/> method does allow 
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IToken`1">
            <summary>The methods of <see cref="T:Loyc.Syntax.Lexing.Token"/> in the form of an interface.</summary>
            <typeparam name="TT">Token Type: the data type of the Type property of 
            <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/> (one often uses int).</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ISimpleToken`1">
            <summary>Basic information about a token as expected by <see cref="T:Loyc.Syntax.BaseParser`1"/>:
            a token <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/>, which is the type of a "word" in the program 
            (string, identifier, plus sign, etc.), a value (e.g. the name of an 
            identifier), and an index where the token starts in the source file.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type">
            <summary>The category of the token (integer, keyword, etc.) used as
            the primary value for identifying the token in a parser.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.StartIndex">
            <summary>Character index where the token starts in the source file.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.Value">
            <summary>Value of the token. The meaning of this property is defined
            by the particular implementation of this interface, but typically this 
            property contains a parsed form of the token (e.g. if the token came 
            from the text "3.14", its value might be <c>(double)3.14</c>.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.TypeInt">
            <summary>Token type.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.StartIndex">
            <summary>Location in the orginal source file where the token starts, or
            -1 for a synthetic token.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.Value">
            <summary>The parsed value of the token.</summary>
            <remarks>The value is
            <ul>
            <li>For strings: the parsed value of the string (no quotes, escape 
            sequences removed), i.e. a boxed char or string. A backquoted string 
            is converted to a Symbol because it is a kind of operator.</li>
            <li>For numbers: the parsed value of the number (e.g. 4 =&gt; int, 4L =&gt; long, 4.0f =&gt; float)</li>
            <li>For identifiers: the parsed name of the identifier, as a Symbol 
            (e.g. x =&gt; x, @for =&gt; for, @`1+1` =&gt; <c>1+1</c>)</li>
            <li>For any keyword including AttrKeyword and TypeKeyword tokens: a 
            Symbol containing the name of the keyword, with "#" prefix</li>
            <li>For punctuation and operators: the text of the punctuation as a 
            symbol (with '#' in front, if the language conventionally uses this 
            prefix)</li>
            <li>For openers (open paren, open brace, etc.) after the tokens have
            been processed by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>: a TokenTree object.</li>
            <li>For spaces and comments: <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/></li>
            <li>When no value is needed (because the Type() is enough): null</li>
            </ul>
            For performance reasons, the text of whitespace is not extracted from
            the source file; <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> is WhitespaceTag.Value for 
            whitespace. Value must be assigned for other types such as 
            identifiers and literals.
            <para/>
            Since the same identifiers and literals are often used more than once 
            in a given source file, an optimized lexer could use a data structure 
            such as a trie or hashtable to cache boxed literals and identifier 
            symbols, and re-use the same values when the same identifiers and 
            literals are encountered multiple times. Done carefully, this avoids 
            the overhead of repeatedly extracting string objects from the source 
            file. If strings must be extracted for some reason (e.g. <c>
            double.TryParse</c> requires an extracted string), at least memory can 
            be saved.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Is(System.Int32,System.Object)">
            <summary>Returns true if the specified type and value match this token.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Range(Loyc.Syntax.ISourceFile)">
            <summary>Gets the <see cref="T:Loyc.Syntax.SourceRange"/> of a token, under the 
            assumption that the token came from the specified source file.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.SourceText(Loyc.Collections.ICharSource)">
            <summary>Gets the original source text for a token if available, under the 
            assumption that the specified source file correctly specifies where the
            token came from. If the token is synthetic, returns <see cref="F:Loyc.UString.Null"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.ToString">
            <summary>Reconstructs a string that represents the token, if possible.
            Does not work for whitespace and comments, because the value of these
            token types is stored in the original source file and for performance 
            reasons is not copied to the token.</summary>
            <remarks>
            This does <i>not</i> return the original source text; it uses a language-
            specific stringizer (<see cref="P:Loyc.Syntax.Lexing.Token.ToStringStrategy"/>).
            <para/>
            The returned string, in general, will not match the original
            token, since the <see cref="P:Loyc.Syntax.Lexing.Token.ToStringStrategy"/> does not have access to
            the original source file.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Equals(Loyc.Syntax.Lexing.Token)">
            <summary>Equality depends on TypeInt and Value, but not StartIndex and 
            Length (this is the same equality condition as <see cref="T:Loyc.Syntax.LNode"/>).</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.ToLNode(Loyc.Syntax.ISourceFile)">
            <summary>Converts a <see cref="T:Loyc.Syntax.Lexing.Token"/> to a <see cref="T:Loyc.Syntax.LNode"/>.</summary>
            <param name="file">This becomes the <see cref="P:Loyc.Syntax.LNode.Source"/> property.</param>
            <remarks>If you really need to store tokens as LNodes, use this. Only
            the <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/>, not the TypeInt, is preserved. Identifiers 
            (where Kind==TokenKind.Id and Value is Symbol) are translated as Id 
            nodes; everything else is translated as a call, using the TokenKind as
            the <see cref="P:Loyc.Syntax.LNode.Name"/> and the value, if any, as parameters. For
            example, if it has been treeified with <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>, the
            token list for <c>"Nodes".Substring(1, 3)</c> as parsed by LES might 
            translate to the LNode sequence <c>String("Nodes"), Dot(@@.), 
            Substring, LParam(Number(1), Separator(@@,), Number(3)), RParen()</c>.
            The <see cref="P:Loyc.Syntax.LNode.Range"/> will match the range of the token.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Kind">
            <summary>Token kind.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Length">
            <summary>Length of the token in the source file, or 0 for a synthetic 
            or implied token.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Style">
            <summary>8 bits of nonsemantic information about the token. The style 
            is used to distinguish hex literals from decimal literals, or triple-
            quoted strings from double-quoted strings.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Children">
            <summary>Returns Value as TokenTree (null if not a TokenTree).</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.EndIndex">
            <summary>Returns StartIndex + Length.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.IsWhitespace">
            <summary>Returns true if Value == <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.ToStringStrategy">
            <summary>Gets or sets the strategy used by <see cref="M:Loyc.Syntax.Lexing.Token.ToString"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ISimpleToken">
            <summary>Alias for ISimpleToken{int}.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenKind">
            <summary>A list of token categories that most programming languages have.</summary>
            <remarks>
            Some Loyc languages will support the concept of a "token literal" which
            is a <see cref="T:Loyc.Syntax.Lexing.TokenTree"/>, and some DSLs will rely on these token 
            literals for input. However, tokens differ between different languages; 
            for instance the set of operators varies between languages. On the other 
            hand, most languages do have some concept of "an operator" and "an 
            identifier", and the TokenKind reflects this fact.
            <para/>
            When you are using <see cref="T:Loyc.Syntax.Lexing.Token"/> to represent tokens in your language,
            it is recommended to define every value of your "TokenType" enumeration in 
            terms of TokenKind using integer offsets, like this:
            <pre>
            enum MyTokenType {
                EOF         = TokenKind.Spaces,
                Id          = TokenKind.Id,
                IfKeyword   = TokenKind.OtherKeyword,
                ForKeyword  = TokenKind.OtherKeyword + 1,
                LoopKeyword = TokenKind.OtherKeyword + 2,
                ...
                MulOp   = TokenKind.Operator,
                AddOp   = TokenKind.Operator + 1,
                DivOp   = TokenKind.Operator + 2,
                DotOp   = TokenKind.Dot,
                ...
            }
            </pre>
            Using TokenKind is only important if you intend to support DSLs via token
            literals (e.g. LLLPG) in your language.
            <para/>
            A DSL that just needs simple tokens like "strings", "identifiers" and "dots" 
            can write a parser based on values of <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/> alone; if 
            it needs certain specific operators or "keywords" that do not have a 
            dedicated TokenKind, such as + and %, it can further check the Value of the 
            token; meanwhile, the host language put a global <see cref="T:Loyc.Symbol"/> 
            in the <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> to represent operators, keywords and 
            identifiers.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Spaces">
            <summary>Spaces, tabs, non-semantic newlines, and EOF</summary>
            <remarks>Spaces and comments are typically filtered out before parsing and will not appear in token literals.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Comment">
            <summary>Single- and multi-line comments</summary>
            <remarks>Spaces and comments are typically filtered out before parsing and will not appear in token literals.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Id">
            <summary>Simple identifiers</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Number">
            <summary>Integers, floats</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.String">
            <summary>e.g. single-quoted, double-quoted, triple-quoted</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.OtherLit">
            <summary>Literals other than numbers and strings</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Dot">
            <summary>Scope operator (dot and dot-like ops such as :: in C++) </summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Assignment">
            <summary>Simple or compound assignment</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Operator">
            <summary>All operators except assignment, dot, or separators</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Separator">
            <summary>e.g. semicolon, comma (if not considered an operator)</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.AttrKeyword">
            <summary>e.g. public, private, static, virtual</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.TypeKeyword">
            <summary>e.g. int, bool, double, void</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.OtherKeyword">
            <summary>e.g. sizeof, struct</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Other">
            <summary>For token types not covered by other token kinds.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokensToTree">
            <summary>
            Converts a token list into a token tree. Everything inside brackets, parens
            or braces is made a child of the open bracket's Block.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.IdNode">
            <summary>Base class of all nodes that represent simple identifiers (including special symbols such as #foo).</summary>
        </member>
        <member name="T:Loyc.Syntax.LNode">
             <summary>All nodes in a Loyc syntax tree share this base class.</summary>
             <remarks>
             Loyc defines only three types of nodes: simple symbols, literals, and calls.
             <ul>
             <li>A <see cref="T:Loyc.Syntax.IdNode"/> is a simple identifier, such as a VariableName</li>
             <li>A <see cref="T:Loyc.Syntax.LiteralNode"/> is a literal constant, such as 123 or "hello"</li>
             <li>A <see cref="T:Loyc.Syntax.CallNode"/> encompasses all other kinds of nodes, such as
             normal function calls like <c>f(x)</c>, generic specifications like <c>f&lt;x&gt;</c>
             (represented <c>#of(f, x)</c>), braced blocks of statements (represented 
             <c>@`{}`(stmt1, stmt2, ...)</c>), and so on. Also, parenthesized expressions
             are represented as a call with one argument and <c>null</c> as the <see cref="P:Loyc.Syntax.LNode.Target"/>.</li>
             </ul>
             This class provides access to all properties of all three types of nodes,
             in order to make this class easier to access from plain C#, and to avoid
             unnecessary downcasting in some cases.
             <para/>
             Loyc nodes are typically immutable, except for the 8-bit <see cref="P:Loyc.Syntax.LNode.Style"/> 
             property which normally affects printing only. If a node allows editing of 
             any other properties, <see cref="P:Loyc.Syntax.LNode.IsFrozen"/> returns false.
             <para/>
             <h3>Background information</h3>
             <para/>
             EC# (enhanced C#) is intended to be the starting point of the Loyc 
             (Language of your choice) project, which will be a family of programming
             languages that will share a common representation for the syntax tree and 
             other compiler-related data structures.
             <para/>
             Just as LLVM assembly has emerged as a nearly universal standard 
             intermediate representation for back-ends, Loyc nodes are intended to be a 
             universal intermediate representation for syntax trees, and Loyc will 
             (eventually) include a generic set of tools for semantic analysis so that
             it provides a generic representation for front-ends.
             <para/>
             EC#, then, will be the first language to use the Loyc syntax tree 
             representation, known as the "Loyc tree" for short. Most syntax trees are 
             very strongly typed, with separate data types for, say, variable 
             declarations, binary operators, method calls, method declarations, unary 
             operators, and so forth. Loyc, however, defines only three types of Nodes,
             and this one class provides access to all the parts of a node. There are 
             several reasons for this design:
             <ul>
             <li>Simplicity. Many projects have thousands of lines of code dedicated 
               to the AST (abstract syntax tree) data structure itself, because each 
               kind of AST node has its own class.</li>
             <li>Serializability. Loyc nodes can always be serialized to a plain text 
               "prefix tree" and deserialized back to objects, even by programs that 
               are not designed to handle the language that the tree represents*. This 
               makes it easy to visualize syntax trees or exchange them between 
               programs.</li>
             <li>Extensibility. Loyc nodes can represent any language imaginable, and
               they are suitable for embedded DSLs (domain-specific languages). Since 
               nodes do not enforce a particular structure, they can be used in 
               different ways than originally envisioned. For example, most languages 
               only have "+" as a binary operator, that is, with two arguments. If  
               Loyc had a separate class for each AST, there would probably be a 
               PlusOperator class derived from BinaryOperator, or something, with 
               properties "Left" and "Right". But since there is only one node class, 
               a "+" operator with three arguments is always possible; this is denoted 
               by #+(a, b, c) in EC# source code.</li>
             </ul>
               * Currently, the only supported syntax for plain-text Loyc trees is 
                 EC# syntax, either normal EC# or prefix-tree notation. As Loyc grows 
                 in popularity, a more universal syntax should be standardized.
             <para/>
             Loyc trees are comparable to LISP trees, except that "attributes" and
             position information are added to the tree, and the concept of a "list" 
             is replaced with the concept of a "call", which I feel is a more 
             intuitive notion in most programming languages that are not LISP.
             <para/>
             Loyc's representation is both an blessing and a curse. The advantage is 
             that Loyc nodes can be used for almost any purpose, perhaps even 
             representing data instead of code in some cases. However, there is no 
             guarantee that a given AST follows the structure prescribed by a particular 
             programming language, unless a special validation step is performed after 
             parsing. In this way, Loyc trees are similar to XML trees, only simpler.
             <para/>
             Another major disadvantage is that it is more difficult to interpret a 
             syntax tree correctly: you have to remember that a method definition has 
             the structure <c>#fn(return_type, name, args, body)</c>, so if "node" is 
             a method definition then <c>node.Args[2]</c> represents the return type, 
             for example. In contrast, most compilers have an AST class called 
             <c>MethodDefinition</c> or something, that provides properties such as 
             Name and ReturnType. Once EC# is developed, however, aliases could help 
             avoid this problem by providing a more friendly veneer over the raw nodes.
             <para/>
             For optimization purposes, the node class is a class hierarchy, but most 
             users should only use this class and perhaps the three derived classes
             <see cref="T:Loyc.Syntax.IdNode"/>, <see cref="T:Loyc.Syntax.LiteralNode"/> and <see cref="T:Loyc.Syntax.CallNode"/>.
             Some users will also find it useful to use <see cref="T:Loyc.Syntax.LNodeFactory"/> for 
             generating synthetic code snippets (bits of code that never existed in any 
             source file), although you can also use the methods defined here in this
             class: <see cref="M:Loyc.Syntax.LNode.Id(Loyc.Symbol,Loyc.Syntax.LNode)"/>(), <see cref="M:Loyc.Syntax.LNode.Literal(System.Object,Loyc.Syntax.LNode)"/>(), <see cref="M:Loyc.Syntax.LNode.Call(Loyc.Symbol,Loyc.Syntax.LNode)"/>(),
             <see cref="M:Loyc.Syntax.LNode.InParens(Loyc.Syntax.LNode)"/>().
             <para/>
             Normal <see cref="T:Loyc.Syntax.LNode"/>s are "persistent" in the comp-sci sense, which 
             means that a subtree can be shared among multiple syntax trees, and nodes
             do not know their own parents. This allows a single node to exist at 
             multiple locations in a syntax tree. This makes manipulation of trees 
             convenient, as there is no need to "detach" a node from one place, or 
             duplicate it, before it can be inserted in another place. Immutable nodes
             can be safely re-used within different source files or multiple versions 
             of one source file in an IDE's "intellisense" or "code completion" engine.
            
             <h3>Loyc and EC#</h3>
             
             Now let's talk about EC# syntax and how it relates to this class.
             <para/>
             EC# supports a generalized C-style syntax which will be described briefly
             here. Basically, almost any code that a programming student might mistake 
             for real C# code is legal, and there is some odd-looking syntax you've 
             never seen before that is also legal.
             <para/>
             Also, virtually any tree of nodes can be represented in EC# source code 
             using a prefix notation, which helps you understand Loyc ASTs because
             the prefix notation closely corresponds to the AST. For example, 
             @=(x, @*(y, 2)) is equivalent to the expression x = y * 2. This notation 
             tells you that 
             - there are two nodes with two arguments each, 
             - the outer one is named "=" and the inner is named "*"
             The syntax tree built from these two representations is identical.
             <para/>
             Prefix notation can be freely mixed with normal EC# code, although usually 
             there is no reason to do so:
             <para/>
             public Point OneTwo = MakePoint(1, 2);
             public #var(Point, Origin(MakePoint(0, 0)));
             public static #fn(MakePoint, #(int x, int y), System.Drawing.Point, #{
            		return new Point(x, y);
            	});
             <para/>
             The prefix notation often involves special identifiers of the form #X, 
             where X is an identifier (or keyword). In the LES and EC# parsers, the # 
             character is considered a normal part of an identifier, no different than
             a letter (A-Z) or an underscore (_). However, the # is "special" in the
             sense that when a special construct (like a method, or a field declaration)
             is converted to a Loyc tree, the Loyc tree represents that special 
             construct using an identifier that starts with "#".
             <para/>
             Code in prefix notation also often has identifiers of the form @X, where X is
             <ol>
             <li>An operator such as + or ==</li>
             <li>A C# keyword</li>
             <li>A backquoted string</li>
             </ol>
             The @ character is <i>not</i> part of the identifier; it merely indicates
             that the characters after the @ symbol represent an identifier, rather than
             an operator or keyword. For example, "==" is normally an operator, and 
             "class" is normally a keyword, but @== and @class are both identifiers,
             not operators or keywords.
             <para/>
             The following examples show how source code text is translated into symbol names:
             <pre>
             #foo     ==&gt; "#foo"        @&gt;&gt;           ==&gt; "&gt;&gt;"
             #?       ==&gt; "?"           @`{}`         ==&gt; "{}"
             #while   ==&gt; "#while"      @`#Newline\n` ==&gt; "#Newline\n"
             @#while  ==&gt; "#while"      @`hi there!`  ==&gt; "hi there!"
             @while   ==&gt; "while"
             </pre>
             Identifiers that start with # are parsed like normal identifiers, but 
             are reserved for things that have special semantic meaning. For example, 
             "#class" is treated by the parser like any other identifier, but it has
             the same semantic meaning as "class", although a structure defined with 
             "#class" looks quite different from the same structure defined using 
             "class". For example, the following forms are equivalent:
             <pre>
             #class(X, #(), @`{}`(int x));
             class X { int x; }
             </pre>
             The #class(...) form uses prefix notation, and it demonstrates the
             structure of the Loyc tree for a class declaration.
             <para/>
             As another example, "#return(7);" is syntactically a function call to a 
             function called "#return". Although the parser treats it like a function 
             call, it produces the same syntax tree as "return 7;" does.
             <para/>
             Ordinary method calls like <c>Foo(x, y)</c> count as prefix notation, and 
             in EC# there is actually a non-prefix notation for this call: <c>x `Foo` y</c>.
             Both forms are equivalent, but the infix notation can only be used when you
             are calling a method that takes two arguments (also, the string `Foo` should
             be a simple identifier; if it contains a dot, it is treated as part of the
             identifier name, not as a normal dot operator.)
             <para/>
             So #class is a keyword that is parsed like an identifier, but this is 
             different from the notation @class which already exists in plain C#.
             @class is an ordinary identifier that has a "@" sign in front to ensure 
             that the compiler does not treat it like a keyword at all. #class is a 
             special identifier that is parsed like an identifier but then treated like 
             a keyword after parsing is complete.
             <para/>
             In other words, to the parser, @struct and #struct are the same except that 
             the parser removes the @ sign but not the # sign. However, later stages of 
             the compiler treat @struct (now stored without the @ sign) and #struct quite 
             differently, as <c>#struct</c> is treated like a keyword and <c>struct</c> 
             is not.
             <para/>
             Since the "#" character is already reserved in plain C# for preprocessor 
             directives, any node name such as "#if" and "#else" that could be mistaken
             for an old-fashioned preprocessor directive must be preceded by "@" at the 
             beginning of a line. For example, the statement "if (failed) return;" can 
             be represented in prefix notation as "@#if(failed, return)", although the 
             node name of "@#if" is actually "#if" (while the node name of the 
             preprocessor directive "#if" would be "##if", and the node name of "return"
             is actually "#return"). Please note that preprocessor directives themselves 
             are not part of the normal syntax tree, because they can appear 
             midstatement. For example, this is valid C#:
             <pre>
             if (condition1
                #if DEBUG
                   &amp;&amp; condition2
                #endif
                ) return;
             </pre>
             Preprocessor statements will be processed early in the compiler and then 
             deleted.
             <para/>
             The special #X tokens don't require an argument list, although the compiler
             expects most of them to have one (and often it must have a specific length).
             Again, this doesn't matter for parsing, only for later stages of analysis.
             <para/>
             Any statement or expression can have attributes attached to it; when 
             attributes are seen beside a statement, they are attached to the root node 
             of that statement. In this example, the attribute is attached to the = 
             operator:
             <pre>
             [PointlessAttribute(true)] x = y * 2;
             </pre>
             Attributes are allowed not just at the beginning of a statement, but at the 
             beginning of any subexpression in parenthesis:
             <pre>
             Debug.Assert(x == ([PointlessAttribute(true)] y + 2));
             </pre>
             Here, the PointlessAttribute is attached to the addition operator (+).
             These attributes are simply normal EC# nodes (arbitrary expressions), so 
             they don't have to look like normal attributes:
             <pre>
             [TheKing is dead] LongLive(TheKing);
             </pre>
             Applying attributes to executable statements has no predefined meaning; A 
             warning is issued if the compiler encounters an attribute where one is not 
             allowed in plain C#, or if the syntax cannot be interpreted as an 
             attribute. The parser supports this feature because it is sometimes useful 
             in metaprogramming and DSLs.
             <para/>
             Because an attribute must be attached to something, an "assembly:" 
             attribute is represented as an #assembly node with an attribute attached:
             <pre>
             [assembly: AssemblyTitle("MyApp")]  // Normal EC#
             [AssemblyTitle("MyApp")] #assembly; // The way EC# sees it internally
             </pre>
             (assembly and module attributes must be special-cased anyway, since it 
             doesn't make sense for them to be attached to whatever follows them.)
             <para/>
             Unlike in plain C#, by the way, EC# labels do not have to be attached to 
             anything; they are considered statements by themselves:
             <pre>
             void f() {
                goto end;
                end:       // OK in EC#, syntax error in plain C#
             }
             </pre>
             Perhaps the most interesting thing about EC# is that it is actually an 
             expression-based language, like LISP: everything in EC# can be considered
             an expression! For example, instead of writing a method as a list of 
             statements, we can write it as a list of expressions:
             <pre>
             // Normal EC#
            	public static char HexDigitChar(int value)
            	{
            		Debug.Assert(16u &gt; (uint)value);
            		if ((uint)value &gt;= 10)
            			return (char)('A' - 10 + value);
            		else
            			return (char)('0' + value);
            	}
            	// Bizarro EC#
            	[#public, #static] #fn(HexDigitChar, #(#var(int, value)), #char, #
            	(
            		Debug.Assert(16u &gt; (uint)value),
            		#if ((uint)value &gt;= 10,
            			#return((char)('A' - 10 + value)),
            			#return((char)('0' + value)));
            	);
             </pre>
             Just so we're clear, you're not supposed to write "bizarro" code, but this
             notation can help you understand the underlying representation. The parser
             basically operates in two modes, one for expressions and one for
             statements. Statement mode allows certain constructs like "if", "while" 
             and "class" that expression mode does not understand. But once parsing is 
             finished, the code is just a tree of nodes with almost nothing to
             distinguish statements from expressions.
             <para/>
             EC# adopts a convention from LISP: the value of the final statement in a 
             block is the value of the block as a whole. This can be used to simplify 
             method and property definitions:
             <para/>
            	int _value;
            	public int Value { get { _value } }
             <para/>
             The EC# if-else and switch statements (but not loops) work the same way, 
             and you can put a braced block in the middle of any expression:
             <pre>
             int hexChar = {
            			if ((uint)value &gt;= 10)
            				'A' - 10
            			else
            				'0'
            		} + value;
             </pre>
             The braced block is represented by a {} node, which introduces a new scope.
             In contrast, the special # node type (the "list marker"), does not create 
             a new scope. It is normally used with expression syntax:
             <pre>
             var three = #(Console.WriteLine("Fetching the three!"), 3);
             var eight = #(int x = 5, three + x);
             var seven = x + 2;
             </pre>
             Since # does not create a new scope, the variable "x" is created in the 
             outer scope, where it can be used to compute the value of seven.
             The # keyword is intended mostly to express lists with prefix notation, but 
             it can be used with braces in case there is a need to switch back to 
             statement notation. 
             <para/>
             The above code is a bit confusing because of how it is written; EC# is 
             meant for mature people who have enough sense not to write confusing code 
             like this.
             
             <h3>The reimplementation</h3>
             
             This implementation has been redesigned (in Subversion, the last version
             based on the old design is revision 289.) The core concept is the same as 
             described in my blog at
             http://loyc-etc.blogspot.ca/2013/04/the-loyc-tree-and-prefix-notation-in-ec.html
             except that the concept of a "Head" has mostly been eliminated, although
             you might see it occasionally because it still has a meaning. The "head"
             of a node refers either to the Name of a symbol, the Value of a literal,
             or the Target of a call (i.e. the name of the method being called, which
             could be an arbitrarily complex node). In the original implementation, it 
             was also possible to have a complex head (a head that is itself a node) 
             even when the node was not a call; this situation was used to represent
             an expression in parenthesis.
             <para/>
             This didn't quite feel right, so I changed it. Now, only calls can be
             complex, and the head of a call (the method being called) is called the
             Target.
             <para/>
             In the new version, there are explicitly three types of nodes: symbols, 
             literals, and calls. There is no longer a Head property, instead there 
             are three separate properties for the three kinds of heads, <see cref="P:Loyc.Syntax.LNode.Name"/> (a Symbol), <see cref="P:Loyc.Syntax.LNode.Value"/> (an Object), and <see cref="P:Loyc.Syntax.LNode.Target"/> (an LNode). Only call nodes have a Target, and only 
             literal nodes have a Value (as an optimization, <see cref="T:Loyc.Syntax.StdTriviaNode"/> breaks this rule; it can only do this because it
             represents special attributes that are outside the normal syntax tree,
             such as comments). Symbol nodes have a Name, but I thought it would be 
             useful for some call nodes to also have a Name, which is defined as the 
             name of the Target if the Target is a symbol (if the Target is not a 
             symbol, the Name must be blank.)
             <para/>
             An expression in parenthesis is now represented by a call with a blank
             name (use <see cref="M:Loyc.Syntax.LNode.IsParenthesizedExpr"/> to detect this case; it is
             incorrect to test <c><see cref="P:Loyc.Syntax.LNode.Name"/> == $``</c> because a call with 
             a non-symbol Target also has a blank name.)
             <para/>
             The following differences in implementation have been made:
             <ul>
             <li>"Red" and "green" nodes have basically been eliminated, at least for now.</li>
             <li>Nodes normally do not contain parent references anymore</li>
             <li>Mutable nodes have been eliminated, for now.</li>
             <li>There are now three standard subclasses, <see cref="T:Loyc.Syntax.IdNode"/>,
                 <see cref="T:Loyc.Syntax.LiteralNode"/> and <see cref="T:Loyc.Syntax.CallNode"/>, and a node
                 can no longer change between classes after it is created.</li>
             <li>An empty Name is now allowed. A literal now has a blank name (instead 
                 of #literal) and a method that calls anything other than a simple symbol
                 will also have a blank Name. Note:
                 The <see cref="P:Loyc.Syntax.LNode.Name"/> property will still never return null.</li>
             <li>As mentioned, an expression in parenthesis is represented differently.</li>
             </ul>
             The problems that motivated a redesign are described at
             http://loyc-etc.blogspot.ca/2013/05/redesigning-loyc-tree-code.html
             <para/>
             One very common use of mutable nodes is building lists of statements, e.g. 
             you might create an empty braced block or an empty loop and then add 
             statements to the body of the block or loop. To do this without mutable 
             nodes, create a mutable <see cref="T:Loyc.Collections.RWList`1"/> instead and add 
             statements there; once the list is finished, create the braced block or
             loop afterward. The new design stores arguments and attributes in 
             <see cref="T:Loyc.Collections.RVList`1"/> objects; you can instantly convert your WList 
             to a VList by calling <see cref="M:Loyc.Collections.WListBase`1.ToRVList"/>.
             <para/>
             During the redesign I've decided on some small changes to the representation
             of certain expressions in EC#.
             <ul>
             <li>The '.' operator is now treated more like a normal binary operator; 
                 <c>a.b.c</c> is now represented <c>#.(#.(a, b), c)</c> rather than 
                 <c>#.(a, b, c)</c> mainly because it's easier that way, and because the 
                 second representation doesn't buy anything significant other than a 
                 need for special-casing.</li>
             <li><c>int x = 0</c> will now be represented <c>#var(int, x = 0)</c>
                 rather than <c>#var(int, x(0))</c>. I chose the latter representation 
                 initially because it is slightly more convenient, because you can 
                 always learn the name of the declared variable by calling 
                 <c>var.Args[1].Name</c>. However, I decided that it was more important
                 for the syntax tree to be predictable, with obvious connections between
                 normal and prefix notations. Since I decided that <c>alias X = Y;</c> 
                 was to be represented <c>#alias(X = Y, #())</c>, it made sense for the 
                 syntax tree of a variable declaration to also resemble its C# syntax. 
                 There's another small reason: C++ has both styles <c>Foo x(y)</c> and 
                 <c>Foo x = y</c>; if Loyc were to ever support C++, it would make sense 
                 to use <c>#var(Foo, x(y))</c> and <c>#var(Foo, x = y)</c> for these two 
                 cases, and I believe C#'s variable declarations are semantically closer 
                 to the latter. (Note: another possibility was #var(int, x) = 0, but I 
                 decided this wasn't an improvement, it would just shift the pain around.)</li>
             <li>An constructor argument list is required on <i>all</i> types using the #new
                 operator, e.g. <c>new int[] { x }</c> must have an empty set of arguments
                 on int[], i.e. <c>#new(#of(#[],int)(), x)</c>; this rule makes the 
                 different kinds of new expressions easier to interpret by making them 
                 consistent with each other.</li>
             <li>A missing syntax element is now represented by an empty symbol instead 
                 of the symbol #missing.</li>
             <li>I've decided to adopt the "in-expression" generics syntax from Nemerle 
                 as an unambiguous alternative to angle brackets: List.[int] means 
                 List&lt;int&gt; and the printer will use this syntax in cases where angle 
                 brackets are ambiguous.</li>
             <li>By popular demand, constructors will be written this(...) instead
                 of new(...), since both D and Nemerle use the latter notation.</li>
             <li>The \ and $ characters have been swapped; \S now denotes a symbol S,
                 while $S now denotes a substitution.</li>
             <li>The \ and $ characters have been swapped; \S now denotes a symbol S,
                 while $S now denotes a substitution. Originally EC# was designed just
                 as an extension of C#, so \ made sense as a substitution operator for
                 string interpolation because it doesn't hurt backward compatibility:
                 "Loaded '\(filename)' successfully". But now that my focus has shifted 
                 to multi-language interoperability, $ makes more sense, as it is used 
                 for string interpolation in at least five other languages and it makes
                 sense to use the same character for both string substitution and code
                 substitution.</li>
             </ul>
             
             <h3>Important properties</h3>
             
             The main properties of a node are
             <ol>
             <li><see cref="P:Loyc.Syntax.LNode.Attrs"/>: holds the attributes of the node, if any.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Name"/>: the name of an <see cref="T:Loyc.Syntax.IdNode"/>, or the name 
                of the <see cref="T:Loyc.Syntax.IdNode"/> that is acting as the <see cref="P:Loyc.Syntax.LNode.Target"/> 
                of a <see cref="T:Loyc.Syntax.CallNode"/>.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Value"/>: the value of a <see cref="T:Loyc.Syntax.LiteralNode"/>.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Target"/>: the target of a <see cref="T:Loyc.Syntax.CallNode"/>. It 
                represents a method, macro, or special identifier that is being called.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Args"/>: holds the arguments to a <see cref="T:Loyc.Syntax.CallNode"/>,
                if any. Returns an empty list if the node does not have an argument list.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Range"/>: indicates the source file that the node came from
                and location in that source file.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Style"/>: an 8-bit flag value that is used as a hint to the
                node printer about how the node should be printed. For example, a hex
                literal like 0x10 has the <see cref="F:Loyc.Syntax.NodeStyle.Alternate"/> style to
                distinguish it from decimal literals such as 16. Custom display styles 
                that do not fit in the Style property can be expressed with attributes.</li>
             </ol>
             <para/>
             The argument and attribute lists cannot be null, since they have type 
             <see cref="T:Loyc.Collections.RVList`1"/> which is a struct.
             <para/>
             <c>LNode</c> implements <see cref="T:Loyc.Collections.INegListSource`1"/>, so you can loop 
             through all children of the node like this:
             <code>
             for (int i = node.Min; i &lt;= node.Max; i++) {
                 LNode child = node[i];
             }
             </code>
             You can also use <c>foreach</c>. The children are numbered like this:
             <ul>
             <li>if i is less than -1, node[i] refers to an attribute. Specifically, node[i] 
             means node.Attrs[i + node.Attrs.Count + 1] in that case.</li>
             <li>node[-1] refers to <c>Target</c> (but throws if there is no target)</li>
             <li>Non-negative values are indexes of Args, e.g. node[i] means node.Args[i].</li>
             </ul>
             LNode also provides <c>Select(child =&gt; result)</c> and <c>ReplaceRecursive(child =&gt; result)</c>
             methods which allows you to transform all children (Atrrs, Target and Args).
             Currently there is no <c>Where(child =&gt; bool)</c> method because it is not
             possible to remove the <see cref="P:Loyc.Syntax.LNode.Target"/> of an LNode (you can still use
             standard LINQ Where(), of course, but the result is not an LNode).
             
             <h3>Note</h3>
             
             The argument and attribute lists should never contain null nodes. Any code 
             that puts nulls in <see cref="P:Loyc.Syntax.LNode.Args"/> or <see cref="P:Loyc.Syntax.LNode.Attrs"/> is buggy. 
             However, we can't ensure nulls are not placed into <see cref="T:Loyc.Collections.RVList`1"/> 
             since it's a general-purpose data type, not specialized for LNode. There is
             code to ensure nulls are not placed in Args and Attrs (<see cref="M:Loyc.Syntax.LNode.NoNulls(Loyc.Collections.RVList{Loyc.Syntax.LNode},System.String)"/>),
             but only in debug builds, since null-checking is fairly expensive.
             </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithName(Loyc.Symbol)">
            <summary>Creates a node with a new value for Name.</summary>
            <remarks>If IsId, the Name is simply changed. If <see cref="P:Loyc.Syntax.LNode.IsCall"/>, 
            this method returns the equivalent of <c>WithTarget(Target.WithName(name))</c>
            (which may be optimized for the particular call type). If <see cref="P:Loyc.Syntax.LNode.IsLiteral"/>, the <see cref="P:Loyc.Syntax.LNode.Kind"/> changes to <see cref="F:Loyc.Syntax.LNodeKind.Id"/> in
            order to set the name.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithValue(System.Object)">
            <summary>Creates a new literal node with a different Value than the current literal node.</summary>
            <exception cref="T:System.InvalidOperationException">The node was not a literal already.</exception>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithArgs(Loyc.Collections.RVList{Loyc.Syntax.LNode})">
            <summary>Creates a Node with a new argument list. If this node is not a 
            call, a new node is created using this node as its target. Otherwise,
            the existing argument list is replaced.</summary>
            <param name="args">New argument list</param>
        </member>
        <member name="M:Loyc.Syntax.LNode.With(Loyc.Syntax.LNode,Loyc.Collections.RVList{Loyc.Syntax.LNode})">
            <summary>Creates a <see cref="T:Loyc.Syntax.CallNode"/> with the same attributes and 
            <see cref="P:Loyc.Syntax.LNode.Range"/>, but a different target and argument list. If the 
            current node is not a CallNode, it becomes one (the Range, Style and 
            attributes of the current node are kept, but the Kind, Value, and 
            Name are discarded.)</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.With(Loyc.Symbol,Loyc.Collections.RVList{Loyc.Syntax.LNode})">
            <summary>Creates a <see cref="T:Loyc.Syntax.CallNode"/> with the same attributes and 
            <see cref="P:Loyc.Syntax.LNode.Range"/>, but a different target and argument list. If the 
            current node is not a CallNode, it becomes one (the Range, Style and 
            attributes of the current node are kept, but the Kind, Value, and 
            Name are discarded.)</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.Clone">
            <summary>Creates a copy of the node. Since nodes are immutable, there 
            is little reason for an end-user to call this, but Clone() is used 
            internally as a helper method by the WithXyz() methods.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.LNodePrinter)">
            <summary>Helps you change printers temporarily. Usage in C#: 
            <c>using (LNode.PushPrinter(myPrinter)) { ... }</c></summary>
            <remarks>For example, to switch to the EC# printer, use
            <c>using (LNode.PushPrinter(EcsNodePrinter.Printer)) { ... }</c>.
            This changes the default printer. If you don't want to change the
            default printer, please invoke the printer directly: 
            <code>
                var sb = new StringBuilder();
                EcsNodePrinter.Printer(node, sb, MessageSink.Trace);
            </code>
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.LNode,Loyc.Syntax.LNode,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.LNode,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Collections.RVList{Loyc.Syntax.LNode},Loyc.Collections.RVList{Loyc.Syntax.LNode},System.Boolean)">
            <summary>Compares two lists of nodes for structural equality.</summary>
            <param name="compareStyles">Whether to compare values of <see cref="P:Loyc.Syntax.LNode.Style"/></param>
            <remarks>Position information is not compared.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.LNode,System.Boolean)">
            <summary>Compares two nodes for structural equality. Two green nodes 
            are considered equal if they have the same name, the same value, the
            same arguments, and the same attributes. IsCall must be the same, but
            they need not have the same values of SourceWidth or IsFrozen.</summary>
            <param name="compareStyles">Whether to compare values of <see cref="P:Loyc.Syntax.LNode.Style"/></param>
            <remarks>Position information (<see cref="P:Loyc.Syntax.LNode.Range"/>) is not compared.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.GetHashCode">
            <summary>Gets the hash code based on the structure of the tree.</summary>
            <remarks>
            If the tree is large, less than the entire tree is scanned to produce 
            the hashcode (in the absolute worst case, about 4000 nodes are examined, 
            but usually it is less than 100).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.HasSimpleHead">
            <summary>Returns true if the Target is an Id or a Literal, and the Target has no attributes.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.HasSimpleHeadWithoutPAttrs">
            <summary>Returns true if the Target is an Id or a Literal, and the Target has only trivia attributes.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.MergeLists(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Some <see cref="T:Loyc.Syntax.CallNode"/>s are used to represent lists. This 
            method merges two nodes, forming or appending a list (see remarks).</summary>
            <param name="node1">First node, list, or null.</param>
            <param name="node2">Second node, list, or null.</param>
            <param name="listName">The <see cref="P:Loyc.Syntax.LNode.Name"/> used to detect whether a 
            node is a list (typically "#splice"). Any other name is considered a 
            normal call, not a list. If this method creates a list from two non-
            lists, this parameter specifies the Name that the list will have.</param>
            <returns>The merged list.</returns>
            <remarks>
            The order of the data is retained (i.e. the data in node1 is inserted
            before the data in node2).
            <ul>
            <li>If either node1 or node2 is null, this method returns the other (node1 ?? node2).</li>
            <li>If both node1 and node2 are lists, this method merges the list 
            into a single list by appending node2's arguments at the end of node1.
            The attributes of node1 are kept and those of node2 are discarded.</li>
            <li>If one of the nodes is a list and the other is not, the non-list
            is inserted into the list's Args.</li>
            <li>If neither node is a list, a list is created with both nodes as 
            its two Args.</li>
            </ul>
            </remarks>
            <seealso cref="M:Loyc.Syntax.LNodeExt.WithSpliced(Loyc.Collections.RVList{Loyc.Syntax.LNode},System.Int32,Loyc.Syntax.LNode,Loyc.Symbol)"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.Select(System.Func{Loyc.Syntax.LNode,Loyc.Syntax.LNode})">
            <summary>Transforms the attributes, <see cref="P:Loyc.Syntax.LNode.Target"/>, and parameters 
            of an LNode, returning another LNode of the same Kind. If the selector
            makes no changes, Select() returns <c>this</c>.</summary>
            <remarks>The selector is not allowed to return null.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.ReplaceRecursive(System.Func{Loyc.Syntax.LNode,Loyc.Syntax.LNode},System.Boolean)">
            <summary>Performs a recursive find-and-replace operation, by attempting
            to replace each child (among <see cref="P:Loyc.Syntax.LNode.Attrs"/>, <see cref="P:Loyc.Syntax.LNode.Target"/>, 
            <see cref="P:Loyc.Syntax.LNode.Args"/>) using the specified selector. This method can also
            be used for simple searching, by giving a selector that always returns 
            null.</summary>
            <param name="selector">The selector is called for each descendant, and
            optionally the root node. If the selector returns a node, the new node 
            replaces the node that was passed to <c>selector</c> and the children of 
            the new node are ignored. If the selector returns null, children of the 
            child are scanned recursively.</param>
            <param name="replaceRoot">Whether to call <c>selector(this)</c>.</param>
        </member>
        <member name="P:Loyc.Syntax.LNode.Range">
            <summary>Returns the location and range in source code of this node.</summary>
            <remarks>
            A parser should record a sufficiently wide range for each parent node, 
            such that all children are fully contained within the range. However, 
            this is not an invariant; macros can splice together syntax trees from 
            different source files or add synthetic nodes, so that the parent range
            does not necessarily include all child ranges. (In fact, in general it 
            is impossible to ensure that parent ranges include child ranges because
            a parent can only specify a single source file, while children can come
            from several source files.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Source">
            <summary>Returns the source file (shortcut for <c><see cref="P:Loyc.Syntax.LNode.Range"/>.Source</c>).</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.LocationString">
            <summary>Gets Range.Begin.ToString().</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Style">
            <summary>Indicates the preferred style to use when printing the node to a text string.</summary>
            <remarks>
            The Style is an 8-bit value that acts as a hint to the node printer about 
            how the node should be printed. Custom display styles that do not fit in 
            the Style property can be expressed with special attributes that have a
            <see cref="P:Loyc.Syntax.LNode.Name"/> starting with "#trivia_". ("#trivia" attributes, which
            are also used to store comments in the syntax tree, are not printed like
            normal attributes and are normally ignored if the node printer does not 
            specifically recognize them.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Attrs">
            <summary>Returns the attribute list for this node.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.IsFrozen">
            <summary>Returns true if the node is immutable, and false if any part of it can be edited.
            Currently, mutable nodes are not implemented.</summary>
            <remarks>Debugger-hidden until such time as mutable nodes actually exist.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Kind">
            <summary>Returns the <see cref="T:Loyc.Syntax.LNodeKind"/>: Symbol, Literal, or Call.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Name">
            <summary>Returns the Symbol if <see cref="P:Loyc.Syntax.LNode.IsId"/>. If this node is 
            a call (<see cref="P:Loyc.Syntax.LNode.IsCall"/>) and <c>Target.IsId</c> is true, 
            this property returns <c>Target.Name</c>. In all other cases, the name
            is <see cref="F:Loyc.GSymbol.Empty"/>. Shall not return null.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.HasSpecialName">
            <summary>Returns true if <see cref="P:Loyc.Syntax.LNode.Name"/> starts with '#'.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Value">
            <summary>Returns the value of a literal node, or <see cref="F:Loyc.NoValue.Value"/> 
            if this node is not a literal (<see cref="P:Loyc.Syntax.LNode.IsLiteral"/> is false).</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Target">
            <summary>Returns the target of a method call, or null if <see cref="P:Loyc.Syntax.LNode.IsCall"/> 
            is false. The target can be a symbol with no name (<see cref="F:Loyc.GSymbol.Empty"/>)
            to represent a parenthesized expression, if there is one argument.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Args">
            <summary>Returns the argument list of this node. Always empty when <c><see cref="P:Loyc.Syntax.LNode.IsCall"/>==false</c>.</summary>
            <remarks>
            Depending on the <see cref="P:Loyc.Syntax.LNode.Target"/>, Args may represent an actual 
            argument list, or it may represent some other kind of list. For 
            example, if the target is "{}" then Args represents a list of 
            statements in a braced block, and if the target is "&gt;=" then Args 
            represents the two arguments to the "&gt;=" operator.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Printer">
            <summary>Gets or sets the default node printer on the current thread,
            which controls how nodes are serialized to text by default.</summary>
            <remarks>The LES printer is the default, and will be used if you try
            to set this property to null.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.TriviaValue">
            <summary>Gets the value of <c>Args[0].Value</c>, if Args[0] exists; 
            otherwise, returns <see cref="F:Loyc.NoValue.Value"/>.</summary>
            <remarks>"Trivia nodes" are used to efficiently represent the value of
            trivia and non-tree <see cref="T:Loyc.Syntax.Lexing.Token"/>s; they can be created by 
            calling the <see cref="M:Loyc.Syntax.LNode.Trivia(Loyc.Symbol,System.Object,Loyc.Syntax.LNode)"/> function. Since an LNode is not 
            allowed to have both a Name and a Value (as there is no syntax in LES 
            or EC# for such a node), a trivia node pretends that there is an 
            argument list with one item, and that one item is always a literal 
            whose Value is the value stored in the trivia node. Thus, a token node 
            is printed out as <c>TokenType(Value)</c> where <c>Value</c> is some 
            literal.
            <para/>
            If you suspect you're dealing with a trivia node, it is wasteful to 
            actually call <c>node.Args[0].Value</c> since this causes a temporary
            token list to be allocated. Instead you should use this property, which
            returns the token value without allocating memory. Of course, if this 
            property is called on a non-trivia node, it simply returns 
            <c>Args[0].Value</c>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LNode.PushedPrinter">
            <summary>Returned by <see cref="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.LNodePrinter)"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.LNode.DeepComparer">
            <summary>An IEqualityComparer that compares nodes structurally.</summary>
        </member>
        <member name="T:Loyc.Syntax.LiteralNode">
            <summary>Base class of all nodes that represent literal values such as 123 and "foo".</summary>
        </member>
        <member name="T:Loyc.Syntax.CallNode">
            <summary>Base class of all nodes that represent calls such as <c>f(x)</c>, 
            operator calls such as <c>x + y</c>, braced blocks, and all other things 
            that are not simple symbols and literals.</summary>
        </member>
        <member name="T:Loyc.Syntax.NodeScanMode">
            <summary>Specifies which children to enumerate when calling <see cref="M:Loyc.Syntax.LNode.Descendants(Loyc.Syntax.NodeScanMode)"/>().</summary>
            <remarks>TODO code review</remarks>
        </member>
        <member name="T:Loyc.Syntax.DescendantsFrame">
            <summary>Helper class used to enumerate <see cref="M:Loyc.Syntax.LNode.Descendants(Loyc.Syntax.NodeScanMode)"/>().</summary>
            <remarks>TODO code review</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodePrinter">
            <summary>Signature for a method that serializes a Loyc tree to text. Each
            programming language will have one.</summary>
            <param name="node">Node to print</param>
            <param name="target">Output buffer</param>
            <param name="mode">A language-specific way of modifying printer behavior.
            The printer should ignore the mode object if it does not not understand it.</param>
            <param name="indentString">A string to print for each level of indentation, such as a tab or four spaces.</param>
            <param name="lineSeparator">Line separator, typically "\n" or "\r\n".</param>
            <remarks>This delegate only prints to a StringBuilder. Printing directly to 
            a stream requires language-specific facilities.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodeExt">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.LNode"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.AsList(Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Interprets a node as a list by returning <c>block.Args</c> if 
            <c>block.Calls(braces)</c>, otherwise returning a one-item list of nodes 
            with <c>block</c> as the only item.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.AsLNode(Loyc.Collections.RVList{Loyc.Syntax.LNode},Loyc.Symbol)">
            <summary>Converts a list of LNodes to a single LNode by using the list 
            as the argument list in a call to the specified identifier, or, if the 
            list contains a single item, by returning that single item.</summary>
            <param name="listIdentifier">Target of the node that is created if <c>list</c>
            does not contain exactly one item. Typical values include "{}" and "#splice".</param>
            <remarks>This is the reverse of the operation performed by <see cref="M:Loyc.Syntax.LNodeExt.AsList(Loyc.Syntax.LNode,Loyc.Symbol)"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.FindAndReplace(Loyc.Syntax.LNode,System.Func{Loyc.Syntax.LNode,Loyc.Syntax.LNode},System.Boolean)">
            <summary>Recursively runs a replacement function on a Loyc tree.</summary>
            <param name="root">A node to scan recursively (depth-first, starting 
            at the top level).</param>
            <param name="replaceFunc">A user-defined method that returns either 
            (1) null, to do no replacement and request that child nodes be processed,
            or (2) non-null, to replace the input node with an output node. When
            replaceFunc returns a node, <c>FindAndReplace</c> does not recursively
            call replaceFunc again on that node or its children.</param>
            <param name="replaceRoot">If true, <c>replaceFunc</c> is called on the 
            root node. If false, <c>replaceFunc</c> is not called on the root node.</param>
            <returns>The new node produced after all replacements have occurred.</returns>
            <remarks>If <c>replaceFunc</c> always returns null (or if <c>replaceRoot</c>
            is false and the root has no children), <c>FindAndReplace</c> returns 
            <c>root</c>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.MatchesPattern(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Collections.MMap{Loyc.Symbol,Loyc.Syntax.LNode}@,Loyc.Collections.RVList{Loyc.Syntax.LNode}@)">
            <summary>Determines whether one Loyc tree "matches" another. This is 
            different from a simple equality test in that (1) trivia atributes do 
            not have to match, and (2) the pattern can contain placeholders represented
            by calls to $ (the substitution operator) with an identifier as a parameter.
            Placeholders match any subtree, and are saved to the <c>captures</c> map.
            </summary>
            <param name="candidate">A node that you want to compare with a 'pattern'.</param>
            <param name="pattern">A syntax tree that may contain placeholders. A 
            placeholder is a call to the $ operator with one parameter, which must 
            be a simple identifier (otherwise the $ operator is treated literally as
            something that must exist in <c>candidate</c>). The subtree in 
            <c>candidate</c> corresponding to the placeholder is saved in <c>captures</c>.</param>
            <param name="captures">A table that maps placeholder names from 
            <c>pattern</c> to subtrees in <c>candidate</c>. You can set your map to 
            null and a map will be created for you if necessary. If you already have
            a map, you should clear it before calling this method.</param>
            <param name="unmatchedAttrs">On return, a list of trivia attributes in 
            <c>candidate</c> that were not present in <c>pattern</c>.</param>
            <returns>true if <c>pattern</c> matches <c>candidate</c>, false otherwise.</returns>
            <remarks>
            Attributes in patterns are not yet supported.
            <para/>
            This method supports multi-part captures, which are matched to 
            placeholders whose identifier has a #params attribute (for example, if 
            the placeholder is called p, this is written as <c>$(params p)</c> in 
            EC#.) A placeholder that looks like this can match multiple arguments or
            multiple statements in the <c>candidate</c> (or <i>no</i> arguments, or
            no statements), and will become a #splice(...) node in <c>captures</c>
            if it matches multiple items. Multi-part captures are often useful for
            getting lists of statements before and after some required element,
            e.g. <c>{ $(params before); MatchThis($something); $(params after); }</c>
            <para/>
            If the same placeholder appears twice then the two matching items are 
            combined into a single output node (calling #splice).
            <para/>
            If matching is unsuccessful, <c>captures</c> and <c>unmatchedAttrs</c>
            may contain irrelevant information gathered during the attempt to match.
            <para/>
            In EC#, the quote(...) macro can be used to create the LNode object for 
            a pattern.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodeFactory">
            <summary>Contains helper methods for creating <see cref="T:Loyc.Syntax.LNode"/>s.
            An LNodeFactory holds a reference to the current source file (<see cref="P:Loyc.Syntax.LNodeFactory.File"/>) 
            so that it does not need to be repeated every time you create a node.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Trivia(System.String,System.Object)">
            <summary>Creates a trivia node named <c>"#trivia_" + suffix</c> with the 
            specified Value attached.</summary>
            <remarks>This method only adds the prefix <c>#trivia_</c> if it is not 
            already present in the 'suffix' argument.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Trivia(Loyc.Symbol,System.Object,System.Int32,System.Int32)">
            <summary>Creates a trivia node with the specified Value attached.</summary>
            <seealso cref="M:Loyc.Syntax.LNode.Trivia(Loyc.Symbol,System.Object,Loyc.Syntax.LNode)"/>
        </member>
        <member name="T:Loyc.Syntax.LNodeVisitor">
            <summary>Base class for people that want to implement the visitor pattern with <see cref="T:Loyc.Syntax.LNode"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.ILNodeVisitor">
            <summary>Interface for people that want to implement the visitor pattern with <see cref="T:Loyc.Syntax.LNode"/>.
            If your visitor does not need a base class, use <see cref="T:Loyc.Syntax.LNodeVisitor"/> as the base class.</summary>
        </member>
        <member name="T:Loyc.Syntax.NodeStyle">
            <summary>Suggests a printing style when serializing a Loyc tree to text.</summary>
            <remarks>See <see cref="P:Loyc.Syntax.LNode.Style"/>.
            <para/>
            TODO: review, rethink.
            <para/>
            A printer should not throw exceptions unless specifically requested. It 
            should ignore printing styles that it does not allow, rather than throwing.
            <para/>
            Styles may be used in different ways by different parsers, different
            printers and different people. Be careful how you rely on them; they are 
            intended to affect only the appearance of a node when it is printed, not 
            its semantics.
            <para/>
            Please note that language-specific printing styles can be denoted by 
            attaching special attributes recognized by the printer for that language.
            These attributes should have Names starting with the string "#trivia_";
            printers are programmed to ignore trivia attributes that they do not
            understand.</remarks>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Default">
            <summary>No style category is specified; the printer should choose a 
            style automatically.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Expression">
            <summary>The node(s) should be printed as a normal expression, rather
            than using a special or statement notation.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Statement">
            <summary>The node, or its immediate children, should be printed in
            statement notation, if possible in the context in which it is located.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Operator">
            <summary>The node should be printed with infix or suffix notation
            instead of prefix notation if applicable (requests `backquote notation` 
            in LES and EC#).</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.PrefixNotation">
            <summary>The node should be printed in prefix notation, e.g. <c>@.(X, Y)</c>
            instead of <c>X.Y</c>.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.DataType">
            <summary>The node should be printed like a data type, if the type 
            notation is somehow different from expression notation. (Note: in 
            general, one cannot expect data types to have this style).</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Special">
            <summary>A language-specific special notation should be used for this
            node. In LES, this marker requests that the arguments to a call be
            broken out into separate expressions, forming a superexpression, e.g.
            in "x = if c a else b", which actually means "x = if(c, a, else, b)",
            the "if(...)" node will have this style.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.OldStyle">
            <summary>Use an older or backward-compatible notation.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.BaseStyleMask">
            <summary>If s is a NodeStyle, (s &amp; NodeStyle.BaseStyleMask) is the 
            base style (Default, Expression, Statement, PrefixNotation, or PurePrefixNotation).</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Alternate">
            <summary>If this node has two common styles in which it is printed, this
            selects the second (either the less common style, or the EC# style for
            features of C# with new syntax in EC#). In LES and EC#, alternate style
            denotes hex numbers. In EC#, it denotes verbatim strings, x(->int) as 
            opposed to (int)x, x (as Y) as opposed to (x as Y). delegate(X) {Y;} is 
            considered to be the alternate style for X => Y, and it forces parens 
            and braces as a side-effect.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Alternate2">
            <summary>Another alternate style flag. In LES and EC#, this is used for
            binary-format numbers.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Handled">
            <summary>Indicates that some part of a compiler has seen the node and 
            done something with it.</summary>
            <remarks>The idea behind this flag relates to compilers that allow 
            user-defined attributes for plug-ins that add functionality. For 
            example, internationalization plug-in might notice a language marker:
            <code>
               MessageBox.Show([en] "Hello, World!");
            </code>
            If an attribute is not used by any plug-in, the compiler should print 
            a warning that the attribute is unused. This leads to the question, how
            can a compiler tell if an attribute was used or not? The Handled flag
            is one possible mechanism; when any part of the compiler or its plug-
            ins use an attribute, the Handled flag should be set to disable the
            compiler warning.
            <para/>
            Remember that the same node can theoretically appear in multiple
            places in a syntax tree, which typically happens when a statement or
            expression is duplicated by a macro, without being changed. Remember 
            that when a style is changed on such a node, the change is visible at 
            all locations where the same node is used. However, style flags are
            not synchronized between copies of a node.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.StdTriviaNode">
            <summary>A node that has both a Name and a Value. </summary>
            <remarks>
            Since there is no syntax (or <see cref="T:Loyc.Syntax.LNodeKind"/>) for a node that has
            both a Name and a Value, the node pretends that it is has a single argument,
            Args[0], which allows this node to be printed as if it were a normal call
            node. For example, if this node has Name=(Symbol)"PI" and Value=3.1415,
            it will be printed as <c>PI(3.1415)</c>. The <see cref="P:Loyc.Syntax.StdTriviaNode.TriviaValue"/>
            property returns this value (in this case, (object)3.1415). Please note
            that the normal <see cref="P:Loyc.Syntax.LNode.Value"/> is still <see cref="F:Loyc.NoValue.Value"/>
            so that if the node is printed and reparsed, it doesn't behave differently.
            <para/>
            This node type is used to represent tokens and trivia nodes with values.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.OperatorShape">
            <summary>An enum of common operator formats.</summary>
            <remarks>It is intentional that the absolute value of each OperatorShape
            (except Other) is the arity of (number of arguments to) that shape.</remarks>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`3">
            <summary>An implementation of the LLLPG Parser API, used with the LLLPG
            options <c>inputSource</c> and <c>inputClass</c>.</summary>
            <remarks>
            This derived class simply makes public all of the LLLPG APIs which are 
            marked protected in <see cref="T:Loyc.Syntax.BaseParserForList`3"/>.
            </remarks>
            <typeparam name="Token">Data type of complete tokens in the token list. A 
            token contains the type of a "word" in the program (string, identifier, plus 
            sign, etc.), a value (e.g. the name of an identifier), and a range of 
            characters in the source file. See <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/>.
            Note: Token is usually a small struct; this class does not expect it to
            ever be null.</typeparam>
            <typeparam name="MatchType">A data type, usually int, that represents a 
            token type (identifier, operator, etc.) and implements <see cref="T:System.IEquatable`1"/>
            so it can be compared for equality with other token types; this is also the 
            type of the <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/> property.</typeparam>
            <typeparam name="List">Data type of the list that contains the tokens (one 
            often uses IList{Token}, but one could use <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            for potentially higher performance.)</typeparam>
        </member>
        <member name="T:Loyc.Syntax.ParserSourceWorkaround`3">
            <summary>This class only exists to work around a limitation of the C# language:
            "cannot change access modifiers when overriding 'protected' inherited member Error(...)".</summary>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.#ctor(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.Skip">
            <inheritdoc/>
        </member>
        <member name="P:Loyc.Syntax.ParserSource`3.ErrorSink">
            <summary>Gets or sets an object that displays error messages. The 
            default value of this property is null, in which case any error that
            occurs will be thrown as a <c>FormatException</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.ParserSource`3.TokenTypeToString">
            <summary>Converts from MatchType (usually integer) to string (used in 
            error messages).</summary>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`2">
            <summary>Alias for ParserSource{Token, int, IList{Token}}.</summary>
            <typeparam name="Token">Token type (one often uses <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
            <typeparam name="MatchType">Data type of the Type property of 
            <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/> (often set to int).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`1">
            <summary>Alias for ParserSource{Token, int, IList{Token}}.</summary>
            <typeparam name="Token">Token type (one often uses <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.Precedence">
            <summary>Represents the precedence and miscibility of an operator.</summary>
            <remarks>
            This class contains four numbers. The first two, Lo and Hi, are a 
            precedence range that describes how the operator can be mixed with other 
            operators. If one operator's range overlaps another AND the ranges are not 
            equal, then the two operators are immiscible. For example, == and != have 
            the same precedence in EC#, 38..39, so they can be mixed with each other, 
            but they cannot be mixed with &amp; which has the overlapping range 32..45 
            (this will be explained below.)
            <para/>
            The "actual" precedence is encoded in the other two numbers, 
            <see cref="F:Loyc.Syntax.Precedence.Left"/> and <see cref="F:Loyc.Syntax.Precedence.Right"/>. These numbers encode the 
            knowledge that, for example, <c>x &amp; y == z</c> will be parsed as 
            <c>x &amp; (y == z)</c>. Normally, Left and Right are the same. However, some
            operators have different precedence on the left than on the right, a prime
            example being the =&gt; operator: <c>x = a =&gt; y = a</c> is parsed 
            <c>x = (a =&gt; (y = a))</c>; it has very high precedence on the left, but
            very low precedence on the right.
            <para/>
            To understand how this works, remember that a parser scans from left to 
            right. Each time it encounters a new operator, it needs to figure out 
            whether to include that operator in the current (inner) expression or 
            whether to "complete" the inner expression and bind the operator to an
            outer expression instead. The concept of a "precedence floor" can be used 
            to make this decision.
            <para/>
            For example, suppose we start parsing the expression <c>-a.b + c * d + e</c>.
            The parser sees "-" first, which must be a prefix operator since there is 
            no expression on the left. The <see cref="F:Loyc.Syntax.Precedence.Right"/> precedence of unary 
            '-' is 90 in EC#, so that will be the "precedence floor" to parse the 
            right-hand side. Operators above 90 will be permitted in the right-hand 
            side; operators at 90 or below will not.
            <para/>
            The next token is 'a', which is an expression by itself and doesn't have 
            any precedence, so it becomes the initial right-hand expression of '-'.
            Next we have '.', which has a <see cref="F:Loyc.Syntax.Precedence.Left"/> precedence of 100, which 
            is above the precedence floor of 90 so it can be bound to 'a'. The 
            precedence floor (PF) is raised to 100, and the next token 'b' is bound to 
            '.'.
            <para/>
            However, the next token '+' (which must be the binary operator rather than 
            the prefix operator, because there is an expression on the left) cannot be 
            accepted with its precedence of 60. Therefore the expression "a.b" is 
            deemed complete, and the PF is lowered back to 90. Again 60 is less than 
            90, so the expression "-a.b" is also deemed complete and the PF drops to 
            int.MinValue. This expression becomes the left-hand side of the '+' 
            operator. The PF rises to 60, and "c * d" becomes a subexpression because
            the precedence of '*' is 70 &gt; 60. However, next we have '+' with 
            precedence 60, which is not above the PF of 60. Therefore, the 
            subexpression "c * d" is deemed complete and the PF lowers to int.MinValue
            again. Now the '+' can be accepted with a left-hand side of <c>(-(a.b)) + 
            (c * d)</c>, and the right-hand side is, of course, 'e', so the completed
            expression is <c>((-(a.b)) + (c * d)) + e</c>. Hope that helps!
            <para/>
            Notice that <c>a + b + c</c> is parsed <c>(a + b) + c</c>, not 
            <c>a + (b + c)</c>. This is the natural result when the operator's 
            precedence is the same on the left and on the right. However, <c>a = b = c</c>
            is parsed <c>a = (b = c)</c>, because its precedence is 1 on the left and 
            0 on the right. When the parser sees the first '=' it sets the PF to 0 
            because it is about to parse the right side. When it encounters the second 
            '=', the left-hand precedence of that operator is 1 which is higher than 
            the current PF (0) so it is included in the right-hand side of the first 
            '='. This behavior is called "right associativity"; <see cref="P:Loyc.Syntax.Precedence.IsRightAssociative"/> 
            returns true when <c>Left &gt; Right</c>.
            <para/>
            Prefix and suffix operators only have one "side"; you can imagine that the 
            unused side (e.g. the left side of prefix -) has infinite precedence, so 
            that EC# can parse $-x as $(-x) even though the precedence of '-' is 
            supposedly lower than '$'.
            <para/>
            Some languages have a conditional operator (a?b:c) with three parts. In 
            the middle part, the PF must drop to Precedence.MinValue so that it is 
            possible to parse <c>a?b=x:c</c> even though '=' supposedly has lower 
            precedence than the conditional operator. Note that <c>a=b ? c=d : e=f</c> 
            is interpreted <c>a=(b ? c=d : e)=f</c>, so you can see that the precedence 
            of the conditional operator is higher at the "edges".
            <para/>
            The above explanation illustrates the meaning of Left and Right from the
            perspective of a parser, but an actual parser may or may not use the PF 
            concept and PrecedenceRange objects.
            <para/>
            The printer (e.g. <see cref="T:Loyc.Syntax.Les.LesNodePrinter"/>) has a different way of analyzing
            precedence. It starts with a known parse tree and then has to figure out 
            how to output something that the parser will reconstruct into the original
            tree. Making this more difficult is the fact that in Loyc trees, parens are
            significant; therefore the printer cannot simply put expressions in parens
            "just to be safe"--extra parenthesis will change the syntax tree, so round-
            tripping will fail.
            <para/>
            Generally, the printer has two ways of printing any expression tree: (1) 
            with operators (e.g. a+b), and (2) with prefix notation (e.g. #+(a, b)).
            The tree <c>#+(#*(a, b), c)</c> will be printed as "a*b+c" (unless prefix
            notation is specifically requested) because the precedence rules allow it,
            but <c>#*(#+(a, b), c)</c> will be printed as <c>#+(a, b)*c</c> because 
            both "a+b*c" and "(a+b)*c" are different from the original tree.
            <para/>
            While a parser proceeds from left to right, a printer proceeds from parents
            to children. So the printer for #*(#+(a, b), c) starts at #* with no 
            precedence restrictions, and roughly speaking will set the precedence floor
            to <see cref="T:Loyc.Syntax.Les.LesPrecedence"/>.Multiply in order to print its two children.
            Since the precedence of #+ (Add) is below Multiply, the + operator is not
            allowed in that context and either prefix notation or extra parenthesis
            is used as a fallback (depending on the <see cref="P:Loyc.Syntax.Les.LesNodePrinter.AllowExtraParenthesis"/> 
            option that permits <c>(a+b)*c</c>).
            <para/>
            Printing has numerous "gotchas"; the ones related to precedence are
            <ol>
            <li>Although <see cref="T:Loyc.Syntax.Les.LesPrecedence"/>.Add has the "same" precedence on the
                Left and Right, <c>#-(#-(a, b), c)</c> can be printed <c>a - b - c</c> but
                <c>#-(a, #-(b, c))</c> would have to be printed <c>a - #-(b, c)</c> 
                instead. Clearly, the left and right sides must be treated somehow
                differently.</li>
            <li>Similarly, the different arguments in <c>a?b:c</c> and <c>a=&gt;b</c> must
                be treated differently. And careful handling is needed for the dot 
                operator in particular due to its high precedence; e.g. <c>#.(a(b))</c> 
                cannot be printed <c>.a(b)</c> because that would mean <c>#.(a)(b)</c>.</li>
            <li>The LES parser, at least, allows a prefix operator to appear on the 
                right-hand side of any infix or prefix operator, regardless of the 
                precedence of the two operators; "$ ++x" is permitted even though ++ has
                lower precedence than $. Another example is that <c>a.-b.c</c> can be 
                parsed with the interpretation <c>a.(-b).c</c>, even though #- has 
                lower precedence than #$. Ideally the printer would replicate this 
                rule, but whether it does ot not, it also must take care that 
                <c>#.(a, -b.c)</c> is not printed as <c>a.-b.c</c> even though the 
                similar expression <c>#*(a, #-(b.c))</c> can be printed as <c>a*-b.c</c>.</li>
            <li>Prefix notation is needed when an operator's arguments have attributes;
                <c>#+([Foo] a, b)</c> cannot be printed <c>[Foo] a + b</c> because
                that would mean <c>[Foo] #+(a, b)</c>.</li>
            </ol>
            
            <h3>Printing and parsing are different</h3>
            
            This type contains different methods for printers and parsers. A basic 
            difference between them is that printers must make decisions (of whether
            an operator is allowed or not in a given context) based on both sides of
            the operator and both sides of the context (Left and Right), while parsers
            only have to worry about one side. For example, consider the following 
            expression:
            <code>
                a = b + c ?? d
            </code>
            When the parser encounters the "+" operator, it only has to consider 
            whether the precedence of the <i>left-hand side</i> of the "+" operator
            is above the <i>right-hand side</i> of the "=" operator. The fact that
            there is a "??" later on is irrelevant. In contrast, when printing the 
            expression "b + c", both sides of the "+" operator and both sides of the 
            context must be considered. The right-hand side is relevant because if 
            the right-hand operator was "*" instead of "??", the following printout 
            would be wrong:
            <code>
                a = b + c * d   // actual syntax tree: a = #+(b, c) * d
            </code>
            The same reasoning applies to the left-hand side (imagine if "=" was 
            "*" instead.)
            <para/>
            So, naturally there are different methods for parsing and printing.
            For printing you can use <see cref="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)"/>, <see cref="M:Loyc.Syntax.Precedence.LeftContext(Loyc.Syntax.Precedence)"/> and <see cref="M:Loyc.Syntax.Precedence.RightContext(Loyc.Syntax.Precedence)"/>, while for parsing you 
            only need <see cref="M:Loyc.Syntax.Precedence.CanParse(Loyc.Syntax.Precedence)"/> (to raise the precedence floor, simply
            replace the current <see cref="T:Loyc.Syntax.Precedence"/> value with that of the new 
            operator). In a parser, the "current" precedence is represented by 
            <see cref="F:Loyc.Syntax.Precedence.Right"/>; the value of <see cref="F:Loyc.Syntax.Precedence.Left"/> doesn't matter.
            <para/>
            Both printers and parsers can use <see cref="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)"/>.
            
            <h3>Miscibility (mixability)</h3>
            
            Certain operators should not be mixed because their precedence was originally 
            chosen incorrectly, e.g. x &amp; 3 == 1 should be parsed (x &amp; 3) == 1 but is 
            actually parsed x &amp; (3 == 1). To allow the precedence to be repaired 
            eventually, expressions like x &amp; y == z are deprecated in EC#: the parser will 
            warn you if you have mixed operators improperly. PrecedenceRange describes 
            both precedence and miscibility with a simple range of integers. As mentioned
            before, two operators are immiscible if their ranges overlap but are not 
            identical.
            <para/>
            In LES, the precedence range feature (a.k.a. immiscibility) is used to 
            indicate that a specific precedence has not been chosen for an operator. 
            If a precedence is chosen in the future, it will be somewhere within the 
            range.
            
            <h3>Overall Range</h3>
            
            By convention, precedence scales range from 0 to 100 (or slightly higher).
            The precedence numbers are stored in this structure as <c>sbyte</c>s, so the 
            standard range cannot be exceeded by much.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Lo">
            <summary>Lo and Hi specify the miscibility of an operator; see the 
            remarks of <see cref="T:Loyc.Syntax.Precedence"/> for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Hi">
            <summary>Lo and Hi specify the miscibility of an operator; see the 
            remarks of <see cref="T:Loyc.Syntax.Precedence"/> for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Left">
            <summary>Left and Right denote the precedence level on the left and 
            right sides of an operator; see the remarks of <see cref="T:Loyc.Syntax.Precedence"/> 
            for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Right">
            <summary>Left and Right denote the precedence level on the left and 
            right sides of an operator; see the remarks of <see cref="T:Loyc.Syntax.Precedence"/> 
            for details.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.LeftContext(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Auto-raises the precedence floor to 
            prepare to print an expression on the left side of an operator.</summary>
            <param name="outerContext"></param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Syntax.Precedence.RightContext(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Auto-raises the precedence floor to 
            prepare to print an expression on the right side of an operator.</summary>
            <param name="outerContext">Context in which this operator is being printed</param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Returns true if an infix operator 
            with this precedence can appear in the specified context.</summary>
            <remarks>Miscibility must be checked separately (<see cref="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)"/>).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence,System.Boolean)">
            <summary>For use in printers. Returns true if a prefix operator with 
            this precedence can appear in the specified context's right-hand 
            precedence floor.</summary>
            <remarks>It is assumed that the left side of a prefix operator has 
            "infinite" precedence so only the right side is checked. This rule is 
            used by the EC# printer but may not be needed or allowed in all 
            languages (if in doubt, set prefix=false).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)">
            <summary>Returns true if an operator with this precedence is miscible
            without parenthesis with the specified other operator.</summary>
            <remarks><see cref="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)"/> is for parsability, 
            this method is to detect a deprecated or undefined mixing of operators.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanParse(Loyc.Syntax.Precedence)">
            <summary>For use in parsers. Returns true if 'rightOp', an operator
            on the right, has higher precedence than the current operator 'this'.</summary>
            <returns><c>rightOp.Left > this.Right</c></returns>
        </member>
        <member name="P:Loyc.Syntax.Precedence.IsRightAssociative">
            <summary>Returns true if this object represents a right-associative 
            operator such as equals (x = (y = z)), in contrast to left-
            associative operators such as division ((x / y) / z).</summary>
        </member>
        <member name="T:Loyc.Syntax.EmptySourceFile">
            <summary>
            A dummy implementation of ISourceFile that has only a filename, no source text.
            Used as the source file of synthetic syntax nodes.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.IndexPositionMapper">
            <summary>Synonym for <c>IndexPositionMapper&lt;IListSource&lt;char>></c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceFileWithLineRemaps">
            <summary>An wrapper around ISourceFile that applies line remapping 
            information (if the source file uses it).</summary>
            <remarks>
            A preprocessor that supports #line may wrap the original <see cref="T:Loyc.Syntax.ISourceFile"/> in one of these, even when the source file 
            doesn't use #line.
            <para/>
            Call Remaps.AddRemap() and, optionally, Remaps.EndRemap(), to add each
            mapping.
            <para/>
            <see cref="T:Loyc.Syntax.ISourceFile"/> includes <see cref="T:Loyc.Syntax.IIndexPositionMapper"/>
            which allows reverse-mapping from line/position back to index. However,
            a position derived from #line information may be ambiguous (does not 
            always have a unique reverse mapping), and I'd rather avoid the work of 
            reverse mapping anyway. So this class does not perform reverse mapping,
            but forward mappings return <see cref="T:Loyc.Syntax.SourcePosAndIndex"/> which are
            automatically recognized by <see cref="M:Loyc.Syntax.SourceFileWithLineRemaps.LineToIndex(System.Int32)"/> which thereby 
            recovers the original index.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LineRemapper">
            <summary>A small helper class for languages such as C# and C++ that permit 
            the locations reported by error messages to be remapped. This class stores
            and applies such commands (#line in C#/C++)</summary>
            <remarks>
            This is part of <see cref="T:Loyc.Syntax.SourceFileWithLineRemaps"/>.
            One LineRemapper should be created per real source file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.AddRemap(System.Int32,System.Int32,System.String)">
            <summary>Adds a mapping that starts on the specified real line.</summary>
            <remarks>In C++ and C#, a directive like "#line 200" affects the line 
            after the preprocessor directive. So if "#line 200" is on line 10, 
            you'd call AddRemap(11, 200) or possibly AddRemap(10, 199).</remarks>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.EndRemap(System.Int32)">
            <summary>Corresponds to <c>#line default</c> in C#.</summary>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.Remap(System.Int32@,System.String@)">
            <summary>Remaps the specified line number, if a remapping has been created that applies to it.</summary>
            <param name="line">On entry, a real line number. On exit, a remapped line number</param>
            <param name="fileName">This is changed to the user-specified file name 
            string, if and only if a file-name remapping exists and applies here.</param>
            <returns>true if a remapping exists and was applied, false if not.</returns>
        </member>
        <member name="T:Loyc.Syntax.LineAndPos">
            <summary>Holds a line number (Line) and a position in the line (PosInLine).
            This class isn't really needed in Loyc but is separated from SourcePos 
            in case anyone might want position without a filename.</summary>
            <remarks>Numbering starts at one for both numbers. Line=0 signifies 
            nowhere in particular.</remarks>
        </member>
        <member name="T:Loyc.Syntax.SourcePos">
            <summary>Holds a filename (FileName), a line number (Line) and a position in 
            the line (PosInLine), representing a position in a source code file.</summary>
            <remarks>
            Line and column numbering both start at one (1). Line=0 signifies nowhere 
            in particular. Instances are immutable.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.SourcePosAndIndex">
            <summary>A <see cref="T:Loyc.Syntax.SourcePos"/> that also includes the original index 
            from which the Line and PosInLine were derived.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceRange">
            <summary>
            Holds a reference to a source file (ISourceFile&lt;char&gt;) and the
            beginning and end indices of a range in that file.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.StreamCharSource">
            <summary>
            Exposes a stream as an ICharSource, as though it were an array of 
            characters. The stream must support seeking, and if a text decoder 
            is specified, it must meet certain constraints.
            </summary><remarks>
            This class reads small blocks of bytes from a stream, reloading 
            blocks from the stream when necessary. Data is cached with a pair 
            of character buffers, and a third buffer is used to read from the
            stream. A Stream is required rather than a TextReader because
            TextReader doesn't support seeking.
            <para/>
            This class assumes the underlying stream never changes.
            <para/>
            The stream does not (and probably cannot, if I understand the 
            System.Text.Decoder API correctly) save the decoder state at each block 
            boundary. Consequently, only encodings that meet special constraints
            will work with StreamCharSource. These include Encoding.Unicode,
            Encoding.UTF8, and Encoding.UTF32, but not Encoding.UTF7. Using 
            unsupported encodings will cause exceptions and/or or corrupted data 
            output while reading from the StreamCharSource.
            <para/>
            The decoder must meet the following constraints:
            1. Characters must be divided on a byte boundary. UTF-7 doesn't work 
               because some characters are encoded using Base64.
            2. Between characters output by the decoder, the decoder must be 
               stateless. Therefore, encodings that support compression generally 
               won't work.
            3. The decoder must produce at least one character from a group of 
               8 bytes (StreamCharSource.MaxSeqSize).
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._blkOffsets">
            <summary>A sorted list of mappings between byte positions and character 
            indexes. In each Pair(of A,B), A is the character index and B is the byte 
            index. This list is built on-demand.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._reachedEnd">
            <summary>Set true when the last block has been scanned. If true, then
            _eofIndex and _eofPosition indicate the Count and the size of the 
            stream, respectively.</summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._eofIndex">
            <summary>_eofIndex is the character index of EOF if it has been reached 
            or, if not, the index of the first unscanned character. _eofIndex 
            equals _blkOffsets[_blkOffsets.Count-1].A.</summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._eofPosition">
            <summary>_eofPosition is the byte position of EOF if it has been reached 
            or, if not, the position of the first unscanned character. _eofPosition 
            equals _blkOffsets[_blkOffsets.Count-1].B.</summary>
        </member>
        <member name="T:Loyc.Syntax.StreamCharSourceTests">
            <summary>Unit tests of StreamCharSource</summary>
        </member>
    </members>
</doc>
